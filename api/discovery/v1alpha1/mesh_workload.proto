syntax = "proto3";
package discovery.smh.solo.io;
option go_package = "github.com/solo-io/service-mesh-hub/pkg/api/discovery.smh.solo.io/v1alpha1";

import "github.com/solo-io/skv2/api/core/v1/core.proto";
import "service-mesh-hub/api/core/v1alpha1/status.proto";

import "gogoproto/gogo.proto";
option (gogoproto.equal_all) = true;

/**
    The MeshWorkload is an abstraction for a workload/client which mesh-discovery has discovered to be part of a
    given mesh (i.e. its traffic is managed by an in-mesh sidecar).
    The Mesh object has references to the MeshWorkloads which belong to it.
*/
message MeshWorkloadSpec {

    // workload_type specifies configuration to the specific type of workload
    oneof workload_type {
        // information describing workloads backed by Kubernetes Pods.
        KubernertesWorkload kubernetes = 1;
    }

    // The mesh with which this workload is associated
    .core.skv2.solo.io.ObjectRef mesh = 4;

    // Appmesh specific metadata
    AppMesh app_mesh = 5;

    // information describing a Kubernetes-based workload (e.g. a Deployment or DaemonSet)
    message KubernertesWorkload {
        /**
           Resource ref to the underlying kubernetes controller which is managing the pods associated with the workloads.
           It has the generic name controller as it can represent a deployment, daemonset, or statefulset.
        */
        .core.skv2.solo.io.ClusterObjectRef controller = 1;

        /**
            these are the labels directly from the pods that this controller owns
            NB: these labels are read directly from the pod template metadata.labels
            defined in the workload spec.
            We need these to determine which services are backed by this workload, and
            the service backing is determined by the pod labels.
        */
        map<string, string> pod_labels = 2;

        // Service account attached to the pods owned by this controller
        string service_account_name = 3;
    }


    // information relevant to AppMesh-injected workloads
    message AppMesh {
        // The value of the env var APPMESH_VIRTUAL_NODE_NAME on the Appmesh envoy proxy container
        string virtual_node_name = 1;

        // Needed for declaring Appmesh VirtualNode listeners
        repeated ContainerPort ports = 2;

        // k8s application container ports
        message ContainerPort {
            uint32 port = 1;
            string protocol = 2;
        }

    }

}

message MeshWorkloadStatus {

    // The observed generation of the MeshWorkload.
    // When this matches the MeshWorkload's metadata.generation, it indicates that mesh-networking
    // has reconciled the latest version of the MeshWorkload.
    int64 observed_generation = 1;

}

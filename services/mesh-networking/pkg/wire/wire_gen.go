// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package wire

import (
	"context"

	"github.com/solo-io/mesh-projects/cli/pkg/tree/uninstall/config_lookup"
	istio_networking "github.com/solo-io/mesh-projects/pkg/clients/istio/networking"
	"github.com/solo-io/mesh-projects/pkg/clients/istio/security"
	kubernetes_apps "github.com/solo-io/mesh-projects/pkg/clients/kubernetes/apps"
	kubernetes_core "github.com/solo-io/mesh-projects/pkg/clients/kubernetes/core"
	zephyr_discovery "github.com/solo-io/mesh-projects/pkg/clients/zephyr/discovery"
	zephyr_networking "github.com/solo-io/mesh-projects/pkg/clients/zephyr/networking"
	zephyr_security "github.com/solo-io/mesh-projects/pkg/clients/zephyr/security"
	"github.com/solo-io/mesh-projects/pkg/kubeconfig"
	"github.com/solo-io/mesh-projects/pkg/security/certgen"
	"github.com/solo-io/mesh-projects/pkg/selector"
	mc_wire "github.com/solo-io/mesh-projects/services/common/multicluster/wire"
	csr_generator "github.com/solo-io/mesh-projects/services/csr-agent/pkg/csr-generator"
	access_policy_enforcer "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/access/access-control-enforcer"
	istio_enforcer "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/access/access-control-enforcer/istio-enforcer"
	acp_translator "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/access/access-control-policy-translator"
	istio_translator2 "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/access/access-control-policy-translator/istio-translator"
	"github.com/solo-io/mesh-projects/services/mesh-networking/pkg/federation/decider"
	"github.com/solo-io/mesh-projects/services/mesh-networking/pkg/federation/decider/strategies"
	"github.com/solo-io/mesh-projects/services/mesh-networking/pkg/federation/dns"
	"github.com/solo-io/mesh-projects/services/mesh-networking/pkg/federation/resolver"
	istio_federation "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/federation/resolver/meshes/istio"
	networking_multicluster "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/multicluster"
	controller_factories "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/multicluster/controllers"
	traffic_policy_translator "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/routing/traffic-policy-translator"
	istio_translator "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/routing/traffic-policy-translator/istio-translator"
	"github.com/solo-io/mesh-projects/services/mesh-networking/pkg/routing/traffic-policy-translator/preprocess"
	cert_manager "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/security/cert-manager"
	cert_signer "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/security/cert-signer"
	vm_validation "github.com/solo-io/mesh-projects/services/mesh-networking/pkg/validation"
)

// Injectors from wire.go:

func InitializeMeshNetworking(ctx context.Context) (MeshNetworkingContext, error) {
	config, err := mc_wire.LocalKubeConfigProvider()
	if err != nil {
		return MeshNetworkingContext{}, err
	}
	asyncManager, err := mc_wire.LocalManagerProvider(ctx, config)
	if err != nil {
		return MeshNetworkingContext{}, err
	}
	asyncManagerController := mc_wire.AsyncManagerControllerProvider(ctx, asyncManager)
	asyncManagerStartOptionsFunc := mc_wire.LocalManagerStarterProvider(asyncManagerController)
	multiClusterDependencies := mc_wire.MulticlusterDependenciesProvider(ctx, asyncManager, asyncManagerController, asyncManagerStartOptionsFunc)
	virtualMeshCSRControllerFactory := controller_factories.NewVirtualMeshCSRControllerFactory()
	controllerFactories := NewControllerFactories(virtualMeshCSRControllerFactory)
	virtualMeshCSRClientFactory := zephyr_security.VirtualMeshCSRClientFactoryProvider()
	clientFactories := NewClientFactories(virtualMeshCSRClientFactory)
	client := mc_wire.DynamicClientProvider(asyncManager)
	secretsClient := kubernetes_core.NewSecretsClient(client)
	virtualMeshClient := zephyr_networking.NewVirtualMeshClient(client)
	rootCertGenerator := certgen.NewRootCertGenerator()
	virtualMeshCertClient := cert_signer.NewVirtualMeshCertClient(secretsClient, virtualMeshClient, rootCertGenerator)
	signer := certgen.NewSigner()
	virtualMeshCSRDataSourceFactory := csr_generator.NewVirtualMeshCSRDataSourceFactory()
	asyncManagerHandler, err := networking_multicluster.NewMeshNetworkingClusterHandler(asyncManager, controllerFactories, clientFactories, virtualMeshCertClient, signer, virtualMeshCSRDataSourceFactory)
	if err != nil {
		return MeshNetworkingContext{}, err
	}
	meshServiceClient := zephyr_discovery.NewMeshServiceClient(client)
	meshWorkloadClient := zephyr_discovery.NewMeshWorkloadClient(client)
	generatedDeploymentClientFactory := kubernetes_apps.GeneratedDeploymentClientFactoryProvider()
	kubernetesClusterClient := zephyr_discovery.NewControllerRuntimeKubernetesClusterClient(client)
	secretToConfigConverter := kubeconfig.SecretToConfigConverterProvider()
	kubeConfigLookup := config_lookup.NewKubeConfigLookup(kubernetesClusterClient, secretsClient, secretToConfigConverter)
	resourceSelector := selector.NewResourceSelector(meshServiceClient, meshWorkloadClient, generatedDeploymentClientFactory, kubeConfigLookup)
	meshClient := zephyr_discovery.NewMeshClient(client)
	trafficPolicyClient := zephyr_networking.NewTrafficPolicyClient(client)
	trafficPolicyMerger := preprocess.NewTrafficPolicyMerger(resourceSelector, meshClient, trafficPolicyClient)
	trafficPolicyValidator := preprocess.NewTrafficPolicyValidator(meshServiceClient, resourceSelector)
	trafficPolicyPreprocessor := preprocess.NewTrafficPolicyPreprocessor(resourceSelector, trafficPolicyMerger, trafficPolicyValidator)
	dynamicClientGetter := mc_wire.DynamicClientGetterProvider(asyncManagerController)
	virtualServiceClientFactory := istio_networking.VirtualServiceClientFactoryProvider()
	destinationRuleClientFactory := istio_networking.DestinationRuleClientFactoryProvider()
	istioTranslator := istio_translator.NewIstioTrafficPolicyTranslator(dynamicClientGetter, meshClient, meshServiceClient, resourceSelector, virtualServiceClientFactory, destinationRuleClientFactory)
	v := TrafficPolicyMeshTranslatorsProvider(istioTranslator)
	trafficPolicyController, err := LocalTrafficPolicyControllerProvider(asyncManager)
	if err != nil {
		return MeshNetworkingContext{}, err
	}
	meshServiceController, err := LocalMeshServiceControllerProvider(asyncManager)
	if err != nil {
		return MeshNetworkingContext{}, err
	}
	trafficPolicyTranslatorLoop := traffic_policy_translator.NewTrafficPolicyTranslatorLoop(trafficPolicyPreprocessor, v, meshClient, meshServiceClient, trafficPolicyClient, trafficPolicyController, meshServiceController)
	meshWorkloadController, err := LocalMeshWorkloadControllerProvider(asyncManager)
	if err != nil {
		return MeshNetworkingContext{}, err
	}
	virtualMeshController, err := controller_factories.NewLocalVirtualMeshController(asyncManager)
	if err != nil {
		return MeshNetworkingContext{}, err
	}
	virtualMeshFinder := vm_validation.NewVirtualMeshFinder(meshClient)
	meshNetworkingSnapshotValidator := vm_validation.NewVirtualMeshValidator(virtualMeshFinder, virtualMeshClient)
	istioCertConfigProducer := cert_manager.NewIstioCertConfigProducer()
	virtualMeshCertificateManager := cert_manager.NewVirtualMeshCsrProcessor(dynamicClientGetter, meshClient, virtualMeshFinder, virtualMeshCSRClientFactory, istioCertConfigProducer)
	vmcsrSnapshotListener := cert_manager.NewVMCSRSnapshotListener(virtualMeshCertificateManager, virtualMeshClient)
	federationStrategyChooser := strategies.NewFederationStrategyChooser()
	federationDecider := decider.NewFederationDecider(meshServiceClient, meshClient, virtualMeshClient, federationStrategyChooser)
	federationDeciderSnapshotListener := decider.NewFederationSnapshotListener(federationDecider)
	meshNetworkingSnapshotContext := MeshNetworkingSnapshotContextProvider(meshWorkloadController, meshServiceController, virtualMeshController, meshNetworkingSnapshotValidator, vmcsrSnapshotListener, federationDeciderSnapshotListener)
	accessControlPolicyController, err := LocalAccessControlPolicyControllerProvider(asyncManager)
	if err != nil {
		return MeshNetworkingContext{}, err
	}
	accessControlPolicyClient := zephyr_networking.NewAccessControlPolicyClient(client)
	authorizationPolicyClientFactory := security.AuthorizationPolicyClientFactoryProvider()
	istio_translatorIstioTranslator := istio_translator2.NewIstioTranslator(meshClient, dynamicClientGetter, authorizationPolicyClientFactory)
	v2 := AccessControlPolicyMeshTranslatorsProvider(istio_translatorIstioTranslator)
	acpTranslatorLoop := acp_translator.NewAcpTranslatorLoop(accessControlPolicyController, meshServiceController, meshClient, accessControlPolicyClient, resourceSelector, v2)
	istioEnforcer := istio_enforcer.NewIstioEnforcer(dynamicClientGetter, authorizationPolicyClientFactory)
	v3 := GlobalAccessControlPolicyMeshEnforcersProvider(istioEnforcer)
	accessPolicyEnforcerLoop := access_policy_enforcer.NewEnforcerLoop(virtualMeshController, virtualMeshClient, meshClient, v3)
	gatewayClientFactory := istio_networking.NewGatewayClientFactory()
	envoyFilterClientFactory := istio_networking.NewEnvoyFilterClientFactory()
	serviceEntryClientFactory := istio_networking.NewServiceEntryClientFactory()
	serviceClientFactory := kubernetes_core.ServiceClientFactoryProvider()
	configMapClient := kubernetes_core.NewConfigMapClient(client)
	ipAssigner := dns.NewIpAssigner(configMapClient)
	podClientFactory := kubernetes_core.NewPodClientFactory()
	nodeClientFactory := kubernetes_core.NewNodeClientFactory()
	externalAccessPointGetter := dns.NewExternalAccessPointGetter(dynamicClientGetter, podClientFactory, nodeClientFactory)
	istioFederationClient := istio_federation.NewIstioFederationClient(dynamicClientGetter, meshClient, gatewayClientFactory, envoyFilterClientFactory, destinationRuleClientFactory, serviceEntryClientFactory, serviceClientFactory, ipAssigner, externalAccessPointGetter)
	perMeshFederationClients := resolver.NewPerMeshFederationClients(istioFederationClient)
	federationResolver := resolver.NewFederationResolver(meshClient, meshWorkloadClient, meshServiceClient, virtualMeshClient, perMeshFederationClients, meshServiceController)
	meshNetworkingContext := MeshNetworkingContextProvider(multiClusterDependencies, asyncManagerHandler, trafficPolicyTranslatorLoop, meshNetworkingSnapshotContext, acpTranslatorLoop, accessPolicyEnforcerLoop, federationResolver)
	return meshNetworkingContext, nil
}

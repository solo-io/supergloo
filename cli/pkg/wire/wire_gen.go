// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package wire

import (
	"context"
	"io"

	"github.com/solo-io/go-utils/installutils/helminstall"
	cli "github.com/solo-io/mesh-projects/cli/pkg"
	"github.com/solo-io/mesh-projects/cli/pkg/common"
	common_config "github.com/solo-io/mesh-projects/cli/pkg/common/config"
	"github.com/solo-io/mesh-projects/cli/pkg/common/exec"
	"github.com/solo-io/mesh-projects/cli/pkg/common/interactive"
	"github.com/solo-io/mesh-projects/cli/pkg/common/kube"
	"github.com/solo-io/mesh-projects/cli/pkg/common/resource_printing"
	"github.com/solo-io/mesh-projects/cli/pkg/common/usage"
	"github.com/solo-io/mesh-projects/cli/pkg/options"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/check"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/check/healthcheck"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/check/status"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/cluster"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/cluster/deregister"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/cluster/register"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/cluster/register/csr"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/create"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/create/virtualmesh"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/demo"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/demo/cleanup"
	demo_init "github.com/solo-io/mesh-projects/cli/pkg/tree/demo/init"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/explore"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/install"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/istio"
	install2 "github.com/solo-io/mesh-projects/cli/pkg/tree/istio/install"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/istio/operator"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/uninstall"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/uninstall/config_lookup"
	crd_uninstall "github.com/solo-io/mesh-projects/cli/pkg/tree/uninstall/crd"
	helm_uninstall "github.com/solo-io/mesh-projects/cli/pkg/tree/uninstall/helm"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/upgrade"
	upgrade_assets "github.com/solo-io/mesh-projects/cli/pkg/tree/upgrade/assets"
	version2 "github.com/solo-io/mesh-projects/cli/pkg/tree/version"
	"github.com/solo-io/mesh-projects/cli/pkg/tree/version/server"
	"github.com/solo-io/mesh-projects/pkg/api/discovery.zephyr.solo.io/v1alpha1/clientset/versioned"
	"github.com/solo-io/mesh-projects/pkg/auth"
	kubernetes_apiext "github.com/solo-io/mesh-projects/pkg/clients/kubernetes/apiext"
	kubernetes_apps "github.com/solo-io/mesh-projects/pkg/clients/kubernetes/apps"
	kubernetes_core "github.com/solo-io/mesh-projects/pkg/clients/kubernetes/core"
	kubernetes_discovery "github.com/solo-io/mesh-projects/pkg/clients/kubernetes/discovery"
	zephyr_discovery "github.com/solo-io/mesh-projects/pkg/clients/zephyr/discovery"
	zephyr_networking "github.com/solo-io/mesh-projects/pkg/clients/zephyr/networking"
	"github.com/solo-io/mesh-projects/pkg/common/docker"
	"github.com/solo-io/mesh-projects/pkg/kubeconfig"
	"github.com/solo-io/mesh-projects/pkg/version"
	"github.com/solo-io/reporting-client/pkg/client"
	"github.com/spf13/cobra"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

// Injectors from wire.go:

func DefaultKubeClientsFactory(masterConfig *rest.Config, writeNamespace string) (*common.KubeClients, error) {
	clientset, err := kubernetes.NewForConfig(masterConfig)
	if err != nil {
		return nil, err
	}
	secretsClient := kubernetes_core.NewGeneratedSecretsClient(clientset)
	serviceAccountClient := kubernetes_core.NewGeneratedServiceAccountClient(clientset)
	remoteAuthorityConfigCreator := auth.NewRemoteAuthorityConfigCreator(secretsClient, serviceAccountClient)
	rbacClient := auth.RbacClientProvider(clientset)
	remoteAuthorityManager := auth.NewRemoteAuthorityManager(serviceAccountClient, rbacClient)
	clusterAuthorization := auth.NewClusterAuthorization(remoteAuthorityConfigCreator, remoteAuthorityManager)
	helmClient := helminstall.DefaultHelmClient()
	installer := install.HelmInstallerProvider(helmClient, clientset)
	kubernetesClusterClient, err := zephyr_discovery.NewGeneratedKubernetesClusterClient(masterConfig)
	if err != nil {
		return nil, err
	}
	namespaceClient := kubernetes_core.NewGeneratedNamespaceClient(clientset)
	serverVersionClient := kubernetes_discovery.NewGeneratedServerVersionClient(clientset)
	podClient := kubernetes_core.NewGeneratedPodClient(clientset)
	meshServiceClient := zephyr_discovery.NewGeneratedMeshServiceClient(masterConfig)
	clients := healthcheck.ClientsProvider(namespaceClient, serverVersionClient, podClient, meshServiceClient)
	deploymentClient, err := kubernetes_apps.NewGeneratedDeploymentClient(masterConfig)
	if err != nil {
		return nil, err
	}
	imageNameParser := docker.NewImageNameParser()
	deployedVersionFinder := version.NewDeployedVersionFinder(deploymentClient, imageNameParser)
	generatedCrdClientFactory := kubernetes_apiext.NewGeneratedCrdClientFactory()
	crdRemover := crd_uninstall.NewCrdRemover(generatedCrdClientFactory)
	secretToConfigConverter := kubeconfig.SecretToConfigConverterProvider()
	uninstallClients := common.UninstallClientsProvider(crdRemover, secretToConfigConverter)
	inMemoryRESTClientGetterFactory := common_config.NewInMemoryRESTClientGetterFactory()
	uninstallerFactory := helm_uninstall.NewUninstallerFactory()
	kubeConfigLookup := config_lookup.NewKubeConfigLookup(kubernetesClusterClient, secretsClient, secretToConfigConverter)
	clusterDeregistrationClient := deregister.NewClusterDeregistrationClient(crdRemover, inMemoryRESTClientGetterFactory, uninstallerFactory, kubeConfigLookup)
	generatedMeshServiceClientFactory := zephyr_discovery.NewGeneratedMeshServiceClientFactory()
	versionedClientset, err := versioned.NewForConfig(masterConfig)
	if err != nil {
		return nil, err
	}
	meshClient := zephyr_discovery.NewGeneratedMeshClient(versionedClientset)
	virtualMeshClient := zephyr_networking.NewGeneratedVirtualMeshClient(masterConfig)
	kubeClients := common.KubeClientsProvider(clusterAuthorization, installer, helmClient, kubernetesClusterClient, clients, deployedVersionFinder, generatedCrdClientFactory, secretsClient, namespaceClient, uninstallClients, inMemoryRESTClientGetterFactory, clusterDeregistrationClient, kubeConfigLookup, generatedMeshServiceClientFactory, meshClient, virtualMeshClient)
	return kubeClients, nil
}

func DefaultClientsFactory(opts *options.Options) (*common.Clients, error) {
	kubeLoader := common_config.DefaultKubeLoaderProvider(opts)
	imageNameParser := docker.NewImageNameParser()
	serverVersionClient := server.DefaultServerVersionClientProvider(opts, kubeLoader, imageNameParser)
	githubAssetClient := upgrade_assets.DefaultGithubAssetClient()
	assetHelper := upgrade_assets.NewAssetHelper(githubAssetClient)
	masterKubeConfigVerifier := common_config.NewMasterKubeConfigVerifier(kubeLoader)
	unstructuredKubeClientFactory := kube.NewUnstructuredKubeClientFactory()
	deploymentClient := server.NewDeploymentClient(kubeLoader, opts)
	installerManifestBuilder := operator.NewInstallerManifestBuilder()
	operatorManagerFactory := operator.NewOperatorManagerFactory()
	istioClients := common.IstioClientsProvider(installerManifestBuilder, operatorManagerFactory)
	statusClientFactory := status.StatusClientFactoryProvider()
	healthCheckSuite := healthcheck.DefaultHealthChecksProvider()
	csrAgentInstallerFactory := csr.NewCsrAgentInstallerFactory()
	clusterRegistrationClients := common.ClusterRegistrationClientsProvider(csrAgentInstallerFactory)
	clients := common.ClientsProvider(serverVersionClient, assetHelper, masterKubeConfigVerifier, unstructuredKubeClientFactory, deploymentClient, istioClients, statusClientFactory, healthCheckSuite, clusterRegistrationClients)
	return clients, nil
}

func InitializeCLI(ctx context.Context, out io.Writer, in io.Reader) *cobra.Command {
	optionsOptions := options.NewOptionsProvider()
	client := usage.DefaultUsageReporterProvider()
	kubeClientsFactory := DefaultKubeClientsFactoryProvider()
	clientsFactory := DefaultClientsFactoryProvider()
	kubeLoader := common_config.DefaultKubeLoaderProvider(optionsOptions)
	registrationCmd := register.ClusterRegistrationCmd(ctx, kubeClientsFactory, clientsFactory, optionsOptions, out, kubeLoader)
	clusterCommand := cluster.ClusterRootCmd(registrationCmd)
	versionCommand := version2.VersionCmd(out, clientsFactory, optionsOptions)
	imageNameParser := docker.NewImageNameParser()
	fileReader := common.NewDefaultFileReader()
	istioInstallationCmd := install2.BuildIstioInstallationCmd(clientsFactory, optionsOptions, out, in, kubeLoader, imageNameParser, fileReader)
	istioCommand := istio.IstioRootCmd(istioInstallationCmd, optionsOptions)
	upgradeCommand := upgrade.UpgradeCmd(ctx, optionsOptions, out, clientsFactory)
	installCommand := install.InstallCmd(optionsOptions, kubeClientsFactory, kubeLoader, out)
	uninstallCommand := uninstall.UninstallCmd(ctx, out, optionsOptions, kubeClientsFactory, kubeLoader)
	prettyPrinter := status.NewPrettyPrinter()
	jsonPrinter := status.NewJsonPrinter()
	checkCommand := check.CheckCmd(ctx, out, optionsOptions, kubeClientsFactory, clientsFactory, kubeLoader, prettyPrinter, jsonPrinter)
	exploreCommand := explore.ExploreCmd()
	runner := exec.NewShellRunner(in, out)
	initCmd := demo_init.DemoInitCmd(ctx, runner)
	cleanupCmd := cleanup.DemoCleanupCmd(ctx, runner)
	demoCommand := demo.DemoRootCmd(initCmd, cleanupCmd)
	interactivePrompt := interactive.NewSurveyInteractivePrompt()
	resourcePrinter := resource_printing.NewResourcePrinter()
	createVirtualMeshCmd := virtualmesh.CreateVirtualMeshCommand(ctx, out, optionsOptions, kubeLoader, kubeClientsFactory, interactivePrompt, resourcePrinter)
	createRootCmd := create.CreateRootCommand(optionsOptions, createVirtualMeshCmd)
	command := cli.BuildCli(ctx, optionsOptions, client, clusterCommand, versionCommand, istioCommand, upgradeCommand, installCommand, uninstallCommand, checkCommand, exploreCommand, demoCommand, createRootCmd)
	return command
}

func InitializeCLIWithMocks(ctx context.Context, out io.Writer, in io.Reader, usageClient client.Client, kubeClientsFactory common.KubeClientsFactory, clientsFactory common.ClientsFactory, kubeLoader common_config.KubeLoader, imageNameParser docker.ImageNameParser, fileReader common.FileReader, secretToConfigConverter kubeconfig.SecretToConfigConverter, runnner exec.Runner, interactivePrompt interactive.InteractivePrompt, resourcePrinter resource_printing.ResourcePrinter) *cobra.Command {
	optionsOptions := options.NewOptionsProvider()
	registrationCmd := register.ClusterRegistrationCmd(ctx, kubeClientsFactory, clientsFactory, optionsOptions, out, kubeLoader)
	clusterCommand := cluster.ClusterRootCmd(registrationCmd)
	versionCommand := version2.VersionCmd(out, clientsFactory, optionsOptions)
	istioInstallationCmd := install2.BuildIstioInstallationCmd(clientsFactory, optionsOptions, out, in, kubeLoader, imageNameParser, fileReader)
	istioCommand := istio.IstioRootCmd(istioInstallationCmd, optionsOptions)
	upgradeCommand := upgrade.UpgradeCmd(ctx, optionsOptions, out, clientsFactory)
	installCommand := install.InstallCmd(optionsOptions, kubeClientsFactory, kubeLoader, out)
	uninstallCommand := uninstall.UninstallCmd(ctx, out, optionsOptions, kubeClientsFactory, kubeLoader)
	prettyPrinter := status.NewPrettyPrinter()
	jsonPrinter := status.NewJsonPrinter()
	checkCommand := check.CheckCmd(ctx, out, optionsOptions, kubeClientsFactory, clientsFactory, kubeLoader, prettyPrinter, jsonPrinter)
	exploreCommand := explore.ExploreCmd()
	initCmd := demo_init.DemoInitCmd(ctx, runnner)
	cleanupCmd := cleanup.DemoCleanupCmd(ctx, runnner)
	demoCommand := demo.DemoRootCmd(initCmd, cleanupCmd)
	createVirtualMeshCmd := virtualmesh.CreateVirtualMeshCommand(ctx, out, optionsOptions, kubeLoader, kubeClientsFactory, interactivePrompt, resourcePrinter)
	createRootCmd := create.CreateRootCommand(optionsOptions, createVirtualMeshCmd)
	command := cli.BuildCli(ctx, optionsOptions, usageClient, clusterCommand, versionCommand, istioCommand, upgradeCommand, installCommand, uninstallCommand, checkCommand, exploreCommand, demoCommand, createRootCmd)
	return command
}

// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./remote_snapshot.go -destination mocks/remote_snapshot.go

// The Input DiscoveryInputSnapshot contains the set of all:
// * Meshes
// * ConfigMaps
// * Services
// * Pods
// * Endpoints
// * Nodes
// * Deployments
// * ReplicaSets
// * DaemonSets
// * StatefulSets
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the DiscoveryInputSnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/skv2/pkg/resource"
	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/hashicorp/go-multierror"

	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	appmesh_k8s_aws_v1beta2_types "github.com/aws/aws-app-mesh-controller-for-k8s/apis/appmesh/v1beta2"
	appmesh_k8s_aws_v1beta2 "github.com/solo-io/external-apis/pkg/api/appmesh/appmesh.k8s.aws/v1beta2"
	appmesh_k8s_aws_v1beta2_sets "github.com/solo-io/external-apis/pkg/api/appmesh/appmesh.k8s.aws/v1beta2/sets"

	v1 "github.com/solo-io/external-apis/pkg/api/k8s/core/v1"
	v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/core/v1/sets"
	v1_types "k8s.io/api/core/v1"

	apps_v1 "github.com/solo-io/external-apis/pkg/api/k8s/apps/v1"
	apps_v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/apps/v1/sets"
	apps_v1_types "k8s.io/api/apps/v1"
)

// SnapshotGVKs is a list of the GVKs included in this snapshot
var DiscoveryInputSnapshotGVKs = []schema.GroupVersionKind{

	schema.GroupVersionKind{
		Group:   "appmesh.k8s.aws",
		Version: "v1beta2",
		Kind:    "Mesh",
	},

	schema.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "ConfigMap",
	},
	schema.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "Service",
	},
	schema.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "Pod",
	},
	schema.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "Endpoints",
	},
	schema.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "Node",
	},

	schema.GroupVersionKind{
		Group:   "apps",
		Version: "v1",
		Kind:    "Deployment",
	},
	schema.GroupVersionKind{
		Group:   "apps",
		Version: "v1",
		Kind:    "ReplicaSet",
	},
	schema.GroupVersionKind{
		Group:   "apps",
		Version: "v1",
		Kind:    "DaemonSet",
	},
	schema.GroupVersionKind{
		Group:   "apps",
		Version: "v1",
		Kind:    "StatefulSet",
	},
}

// the snapshot of input resources consumed by translation
type DiscoveryInputSnapshot interface {

	// return the set of input Meshes
	Meshes() appmesh_k8s_aws_v1beta2_sets.MeshSet

	// return the set of input ConfigMaps
	ConfigMaps() v1_sets.ConfigMapSet
	// return the set of input Services
	Services() v1_sets.ServiceSet
	// return the set of input Pods
	Pods() v1_sets.PodSet
	// return the set of input Endpoints
	Endpoints() v1_sets.EndpointsSet
	// return the set of input Nodes
	Nodes() v1_sets.NodeSet

	// return the set of input Deployments
	Deployments() apps_v1_sets.DeploymentSet
	// return the set of input ReplicaSets
	ReplicaSets() apps_v1_sets.ReplicaSetSet
	// return the set of input DaemonSets
	DaemonSets() apps_v1_sets.DaemonSetSet
	// return the set of input StatefulSets
	StatefulSets() apps_v1_sets.StatefulSetSet
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)

	// Clone the snapshot
	Clone() DiscoveryInputSnapshot
}

// options for syncing input object statuses
type DiscoveryInputSyncStatusOptions struct {

	// sync status of Mesh objects
	Mesh bool

	// sync status of ConfigMap objects
	ConfigMap bool
	// sync status of Service objects
	Service bool
	// sync status of Pod objects
	Pod bool
	// sync status of Endpoints objects
	Endpoints bool
	// sync status of Node objects
	Node bool

	// sync status of Deployment objects
	Deployment bool
	// sync status of ReplicaSet objects
	ReplicaSet bool
	// sync status of DaemonSet objects
	DaemonSet bool
	// sync status of StatefulSet objects
	StatefulSet bool
}

type snapshotDiscoveryInput struct {
	name string

	meshes appmesh_k8s_aws_v1beta2_sets.MeshSet

	configMaps v1_sets.ConfigMapSet
	services   v1_sets.ServiceSet
	pods       v1_sets.PodSet
	endpoints  v1_sets.EndpointsSet
	nodes      v1_sets.NodeSet

	deployments  apps_v1_sets.DeploymentSet
	replicaSets  apps_v1_sets.ReplicaSetSet
	daemonSets   apps_v1_sets.DaemonSetSet
	statefulSets apps_v1_sets.StatefulSetSet
}

func NewDiscoveryInputSnapshot(
	name string,

	meshes appmesh_k8s_aws_v1beta2_sets.MeshSet,

	configMaps v1_sets.ConfigMapSet,
	services v1_sets.ServiceSet,
	pods v1_sets.PodSet,
	endpoints v1_sets.EndpointsSet,
	nodes v1_sets.NodeSet,

	deployments apps_v1_sets.DeploymentSet,
	replicaSets apps_v1_sets.ReplicaSetSet,
	daemonSets apps_v1_sets.DaemonSetSet,
	statefulSets apps_v1_sets.StatefulSetSet,

) DiscoveryInputSnapshot {
	return &snapshotDiscoveryInput{
		name: name,

		meshes:       meshes,
		configMaps:   configMaps,
		services:     services,
		pods:         pods,
		endpoints:    endpoints,
		nodes:        nodes,
		deployments:  deployments,
		replicaSets:  replicaSets,
		daemonSets:   daemonSets,
		statefulSets: statefulSets,
	}
}

func NewDiscoveryInputSnapshotFromGeneric(
	name string,
	genericSnapshot resource.ClusterSnapshot,
) DiscoveryInputSnapshot {

	meshSet := appmesh_k8s_aws_v1beta2_sets.NewMeshSet()

	configMapSet := v1_sets.NewConfigMapSet()
	serviceSet := v1_sets.NewServiceSet()
	podSet := v1_sets.NewPodSet()
	endpointsSet := v1_sets.NewEndpointsSet()
	nodeSet := v1_sets.NewNodeSet()

	deploymentSet := apps_v1_sets.NewDeploymentSet()
	replicaSetSet := apps_v1_sets.NewReplicaSetSet()
	daemonSetSet := apps_v1_sets.NewDaemonSetSet()
	statefulSetSet := apps_v1_sets.NewStatefulSetSet()

	for _, snapshot := range genericSnapshot {

		meshes := snapshot[schema.GroupVersionKind{
			Group:   "appmesh.k8s.aws",
			Version: "v1beta2",
			Kind:    "Mesh",
		}]

		for _, mesh := range meshes {
			meshSet.Insert(mesh.(*appmesh_k8s_aws_v1beta2_types.Mesh))
		}

		configMaps := snapshot[schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "ConfigMap",
		}]

		for _, configMap := range configMaps {
			configMapSet.Insert(configMap.(*v1_types.ConfigMap))
		}
		services := snapshot[schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Service",
		}]

		for _, service := range services {
			serviceSet.Insert(service.(*v1_types.Service))
		}
		pods := snapshot[schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Pod",
		}]

		for _, pod := range pods {
			podSet.Insert(pod.(*v1_types.Pod))
		}
		endpoints := snapshot[schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Endpoints",
		}]

		for _, endpoints := range endpoints {
			endpointsSet.Insert(endpoints.(*v1_types.Endpoints))
		}
		nodes := snapshot[schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Node",
		}]

		for _, node := range nodes {
			nodeSet.Insert(node.(*v1_types.Node))
		}

		deployments := snapshot[schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "Deployment",
		}]

		for _, deployment := range deployments {
			deploymentSet.Insert(deployment.(*apps_v1_types.Deployment))
		}
		replicaSets := snapshot[schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "ReplicaSet",
		}]

		for _, replicaSet := range replicaSets {
			replicaSetSet.Insert(replicaSet.(*apps_v1_types.ReplicaSet))
		}
		daemonSets := snapshot[schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "DaemonSet",
		}]

		for _, daemonSet := range daemonSets {
			daemonSetSet.Insert(daemonSet.(*apps_v1_types.DaemonSet))
		}
		statefulSets := snapshot[schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "StatefulSet",
		}]

		for _, statefulSet := range statefulSets {
			statefulSetSet.Insert(statefulSet.(*apps_v1_types.StatefulSet))
		}

	}
	return NewDiscoveryInputSnapshot(
		name,
		meshSet,
		configMapSet,
		serviceSet,
		podSet,
		endpointsSet,
		nodeSet,
		deploymentSet,
		replicaSetSet,
		daemonSetSet,
		statefulSetSet,
	)
}

func (s snapshotDiscoveryInput) Meshes() appmesh_k8s_aws_v1beta2_sets.MeshSet {
	return s.meshes
}

func (s snapshotDiscoveryInput) ConfigMaps() v1_sets.ConfigMapSet {
	return s.configMaps
}

func (s snapshotDiscoveryInput) Services() v1_sets.ServiceSet {
	return s.services
}

func (s snapshotDiscoveryInput) Pods() v1_sets.PodSet {
	return s.pods
}

func (s snapshotDiscoveryInput) Endpoints() v1_sets.EndpointsSet {
	return s.endpoints
}

func (s snapshotDiscoveryInput) Nodes() v1_sets.NodeSet {
	return s.nodes
}

func (s snapshotDiscoveryInput) Deployments() apps_v1_sets.DeploymentSet {
	return s.deployments
}

func (s snapshotDiscoveryInput) ReplicaSets() apps_v1_sets.ReplicaSetSet {
	return s.replicaSets
}

func (s snapshotDiscoveryInput) DaemonSets() apps_v1_sets.DaemonSetSet {
	return s.daemonSets
}

func (s snapshotDiscoveryInput) StatefulSets() apps_v1_sets.StatefulSetSet {
	return s.statefulSets
}

func (s snapshotDiscoveryInput) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["meshes"] = s.meshes.List()
	snapshotMap["configMaps"] = s.configMaps.List()
	snapshotMap["services"] = s.services.List()
	snapshotMap["pods"] = s.pods.List()
	snapshotMap["endpoints"] = s.endpoints.List()
	snapshotMap["nodes"] = s.nodes.List()
	snapshotMap["deployments"] = s.deployments.List()
	snapshotMap["replicaSets"] = s.replicaSets.List()
	snapshotMap["daemonSets"] = s.daemonSets.List()
	snapshotMap["statefulSets"] = s.statefulSets.List()
	return json.Marshal(snapshotMap)
}

func (s snapshotDiscoveryInput) Clone() DiscoveryInputSnapshot {
	return &snapshotDiscoveryInput{
		name: s.name,

		meshes:       s.meshes.Clone(),
		configMaps:   s.configMaps.Clone(),
		services:     s.services.Clone(),
		pods:         s.pods.Clone(),
		endpoints:    s.endpoints.Clone(),
		nodes:        s.nodes.Clone(),
		deployments:  s.deployments.Clone(),
		replicaSets:  s.replicaSets.Clone(),
		daemonSets:   s.daemonSets.Clone(),
		statefulSets: s.statefulSets.Clone(),
	}
}

// builds the input snapshot from API Clients.
type DiscoveryInputBuilder interface {
	BuildSnapshot(ctx context.Context, name string, opts DiscoveryInputBuildOptions) (DiscoveryInputSnapshot, error)
}

// Options for building a snapshot
type DiscoveryInputBuildOptions struct {

	// List options for composing a snapshot from Meshes
	Meshes ResourceDiscoveryInputBuildOptions

	// List options for composing a snapshot from ConfigMaps
	ConfigMaps ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from Services
	Services ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from Pods
	Pods ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from Endpoints
	Endpoints ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from Nodes
	Nodes ResourceDiscoveryInputBuildOptions

	// List options for composing a snapshot from Deployments
	Deployments ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from ReplicaSets
	ReplicaSets ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from DaemonSets
	DaemonSets ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from StatefulSets
	StatefulSets ResourceDiscoveryInputBuildOptions
}

// Options for reading resources of a given type
type ResourceDiscoveryInputBuildOptions struct {

	// List options for composing a snapshot from a resource type
	ListOptions []client.ListOption

	// If provided, ensure the resource has been verified before adding it to snapshots
	Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources across multiple clusters
type multiClusterDiscoveryInputBuilder struct {
	clusters multicluster.Interface
	client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterDiscoveryInputBuilder(
	clusters multicluster.Interface,
	client multicluster.Client,
) DiscoveryInputBuilder {
	return &multiClusterDiscoveryInputBuilder{
		clusters: clusters,
		client:   client,
	}
}

func (b *multiClusterDiscoveryInputBuilder) BuildSnapshot(ctx context.Context, name string, opts DiscoveryInputBuildOptions) (DiscoveryInputSnapshot, error) {

	meshes := appmesh_k8s_aws_v1beta2_sets.NewMeshSet()

	configMaps := v1_sets.NewConfigMapSet()
	services := v1_sets.NewServiceSet()
	pods := v1_sets.NewPodSet()
	endpoints := v1_sets.NewEndpointsSet()
	nodes := v1_sets.NewNodeSet()

	deployments := apps_v1_sets.NewDeploymentSet()
	replicaSets := apps_v1_sets.NewReplicaSetSet()
	daemonSets := apps_v1_sets.NewDaemonSetSet()
	statefulSets := apps_v1_sets.NewStatefulSetSet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertMeshesFromCluster(ctx, cluster, meshes, opts.Meshes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertConfigMapsFromCluster(ctx, cluster, configMaps, opts.ConfigMaps); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertServicesFromCluster(ctx, cluster, services, opts.Services); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertPodsFromCluster(ctx, cluster, pods, opts.Pods); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertEndpointsFromCluster(ctx, cluster, endpoints, opts.Endpoints); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNodesFromCluster(ctx, cluster, nodes, opts.Nodes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDeploymentsFromCluster(ctx, cluster, deployments, opts.Deployments); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertReplicaSetsFromCluster(ctx, cluster, replicaSets, opts.ReplicaSets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDaemonSetsFromCluster(ctx, cluster, daemonSets, opts.DaemonSets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertStatefulSetsFromCluster(ctx, cluster, statefulSets, opts.StatefulSets); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewDiscoveryInputSnapshot(
		name,

		meshes,
		configMaps,
		services,
		pods,
		endpoints,
		nodes,
		deployments,
		replicaSets,
		daemonSets,
		statefulSets,
	)

	return outputSnap, errs
}

func (b *multiClusterDiscoveryInputBuilder) insertMeshesFromCluster(ctx context.Context, cluster string, meshes appmesh_k8s_aws_v1beta2_sets.MeshSet, opts ResourceDiscoveryInputBuildOptions) error {
	meshClient, err := appmesh_k8s_aws_v1beta2.NewMulticlusterMeshClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "appmesh.k8s.aws",
			Version: "v1beta2",
			Kind:    "Mesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	meshList, err := meshClient.ListMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range meshList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		meshes.Insert(item)
	}

	return nil
}

func (b *multiClusterDiscoveryInputBuilder) insertConfigMapsFromCluster(ctx context.Context, cluster string, configMaps v1_sets.ConfigMapSet, opts ResourceDiscoveryInputBuildOptions) error {
	configMapClient, err := v1.NewMulticlusterConfigMapClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "ConfigMap",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	configMapList, err := configMapClient.ListConfigMap(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range configMapList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		configMaps.Insert(item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertServicesFromCluster(ctx context.Context, cluster string, services v1_sets.ServiceSet, opts ResourceDiscoveryInputBuildOptions) error {
	serviceClient, err := v1.NewMulticlusterServiceClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Service",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	serviceList, err := serviceClient.ListService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range serviceList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		services.Insert(item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertPodsFromCluster(ctx context.Context, cluster string, pods v1_sets.PodSet, opts ResourceDiscoveryInputBuildOptions) error {
	podClient, err := v1.NewMulticlusterPodClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Pod",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	podList, err := podClient.ListPod(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range podList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		pods.Insert(item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertEndpointsFromCluster(ctx context.Context, cluster string, endpoints v1_sets.EndpointsSet, opts ResourceDiscoveryInputBuildOptions) error {
	endpointsClient, err := v1.NewMulticlusterEndpointsClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Endpoints",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	endpointsList, err := endpointsClient.ListEndpoints(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range endpointsList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		endpoints.Insert(item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertNodesFromCluster(ctx context.Context, cluster string, nodes v1_sets.NodeSet, opts ResourceDiscoveryInputBuildOptions) error {
	nodeClient, err := v1.NewMulticlusterNodeClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Node",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	nodeList, err := nodeClient.ListNode(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range nodeList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		nodes.Insert(item)
	}

	return nil
}

func (b *multiClusterDiscoveryInputBuilder) insertDeploymentsFromCluster(ctx context.Context, cluster string, deployments apps_v1_sets.DeploymentSet, opts ResourceDiscoveryInputBuildOptions) error {
	deploymentClient, err := apps_v1.NewMulticlusterDeploymentClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "Deployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	deploymentList, err := deploymentClient.ListDeployment(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range deploymentList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		deployments.Insert(item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertReplicaSetsFromCluster(ctx context.Context, cluster string, replicaSets apps_v1_sets.ReplicaSetSet, opts ResourceDiscoveryInputBuildOptions) error {
	replicaSetClient, err := apps_v1.NewMulticlusterReplicaSetClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "ReplicaSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	replicaSetList, err := replicaSetClient.ListReplicaSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range replicaSetList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		replicaSets.Insert(item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertDaemonSetsFromCluster(ctx context.Context, cluster string, daemonSets apps_v1_sets.DaemonSetSet, opts ResourceDiscoveryInputBuildOptions) error {
	daemonSetClient, err := apps_v1.NewMulticlusterDaemonSetClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "DaemonSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	daemonSetList, err := daemonSetClient.ListDaemonSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range daemonSetList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		daemonSets.Insert(item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertStatefulSetsFromCluster(ctx context.Context, cluster string, statefulSets apps_v1_sets.StatefulSetSet, opts ResourceDiscoveryInputBuildOptions) error {
	statefulSetClient, err := apps_v1.NewMulticlusterStatefulSetClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "StatefulSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	statefulSetList, err := statefulSetClient.ListStatefulSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range statefulSetList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		statefulSets.Insert(item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterDiscoveryInputBuilder struct {
	mgr         manager.Manager
	clusterName string
}

// Produces snapshots of resources read from the manager for the given cluster
func NewSingleClusterDiscoveryInputBuilder(
	mgr manager.Manager,
) DiscoveryInputBuilder {
	return NewSingleClusterDiscoveryInputBuilderWithClusterName(mgr, "")
}

// Produces snapshots of resources read from the manager for the given cluster.
// Snapshot resources will be marked with the given ClusterName.
func NewSingleClusterDiscoveryInputBuilderWithClusterName(
	mgr manager.Manager,
	clusterName string,
) DiscoveryInputBuilder {
	return &singleClusterDiscoveryInputBuilder{
		mgr:         mgr,
		clusterName: clusterName,
	}
}

func (b *singleClusterDiscoveryInputBuilder) BuildSnapshot(ctx context.Context, name string, opts DiscoveryInputBuildOptions) (DiscoveryInputSnapshot, error) {

	meshes := appmesh_k8s_aws_v1beta2_sets.NewMeshSet()

	configMaps := v1_sets.NewConfigMapSet()
	services := v1_sets.NewServiceSet()
	pods := v1_sets.NewPodSet()
	endpoints := v1_sets.NewEndpointsSet()
	nodes := v1_sets.NewNodeSet()

	deployments := apps_v1_sets.NewDeploymentSet()
	replicaSets := apps_v1_sets.NewReplicaSetSet()
	daemonSets := apps_v1_sets.NewDaemonSetSet()
	statefulSets := apps_v1_sets.NewStatefulSetSet()

	var errs error

	if err := b.insertMeshes(ctx, meshes, opts.Meshes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertConfigMaps(ctx, configMaps, opts.ConfigMaps); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertServices(ctx, services, opts.Services); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertPods(ctx, pods, opts.Pods); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertEndpoints(ctx, endpoints, opts.Endpoints); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNodes(ctx, nodes, opts.Nodes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertDeployments(ctx, deployments, opts.Deployments); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertReplicaSets(ctx, replicaSets, opts.ReplicaSets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertDaemonSets(ctx, daemonSets, opts.DaemonSets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertStatefulSets(ctx, statefulSets, opts.StatefulSets); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewDiscoveryInputSnapshot(
		name,

		meshes,
		configMaps,
		services,
		pods,
		endpoints,
		nodes,
		deployments,
		replicaSets,
		daemonSets,
		statefulSets,
	)

	return outputSnap, errs
}

func (b *singleClusterDiscoveryInputBuilder) insertMeshes(ctx context.Context, meshes appmesh_k8s_aws_v1beta2_sets.MeshSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "appmesh.k8s.aws",
			Version: "v1beta2",
			Kind:    "Mesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	meshList, err := appmesh_k8s_aws_v1beta2.NewMeshClient(b.mgr.GetClient()).ListMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range meshList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		meshes.Insert(item)
	}

	return nil
}

func (b *singleClusterDiscoveryInputBuilder) insertConfigMaps(ctx context.Context, configMaps v1_sets.ConfigMapSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "ConfigMap",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	configMapList, err := v1.NewConfigMapClient(b.mgr.GetClient()).ListConfigMap(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range configMapList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		configMaps.Insert(item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertServices(ctx context.Context, services v1_sets.ServiceSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Service",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	serviceList, err := v1.NewServiceClient(b.mgr.GetClient()).ListService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range serviceList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		services.Insert(item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertPods(ctx context.Context, pods v1_sets.PodSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Pod",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	podList, err := v1.NewPodClient(b.mgr.GetClient()).ListPod(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range podList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		pods.Insert(item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertEndpoints(ctx context.Context, endpoints v1_sets.EndpointsSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Endpoints",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	endpointsList, err := v1.NewEndpointsClient(b.mgr.GetClient()).ListEndpoints(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range endpointsList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		endpoints.Insert(item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertNodes(ctx context.Context, nodes v1_sets.NodeSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Node",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	nodeList, err := v1.NewNodeClient(b.mgr.GetClient()).ListNode(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range nodeList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		nodes.Insert(item)
	}

	return nil
}

func (b *singleClusterDiscoveryInputBuilder) insertDeployments(ctx context.Context, deployments apps_v1_sets.DeploymentSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "Deployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	deploymentList, err := apps_v1.NewDeploymentClient(b.mgr.GetClient()).ListDeployment(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range deploymentList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		deployments.Insert(item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertReplicaSets(ctx context.Context, replicaSets apps_v1_sets.ReplicaSetSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "ReplicaSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	replicaSetList, err := apps_v1.NewReplicaSetClient(b.mgr.GetClient()).ListReplicaSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range replicaSetList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		replicaSets.Insert(item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertDaemonSets(ctx context.Context, daemonSets apps_v1_sets.DaemonSetSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "DaemonSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	daemonSetList, err := apps_v1.NewDaemonSetClient(b.mgr.GetClient()).ListDaemonSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range daemonSetList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		daemonSets.Insert(item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertStatefulSets(ctx context.Context, statefulSets apps_v1_sets.StatefulSetSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "StatefulSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	statefulSetList, err := apps_v1.NewStatefulSetClient(b.mgr.GetClient()).ListStatefulSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range statefulSetList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		statefulSets.Insert(item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type inMemoryDiscoveryInputBuilder struct {
	getSnapshot func() (resource.ClusterSnapshot, error)
}

// Produces snapshots of resources read from the manager for the given cluster
func NewInMemoryDiscoveryInputBuilder(
	getSnapshot func() (resource.ClusterSnapshot, error),
) DiscoveryInputBuilder {
	return &inMemoryDiscoveryInputBuilder{
		getSnapshot: getSnapshot,
	}
}

func (i *inMemoryDiscoveryInputBuilder) BuildSnapshot(ctx context.Context, name string, opts DiscoveryInputBuildOptions) (DiscoveryInputSnapshot, error) {
	genericSnap, err := i.getSnapshot()
	if err != nil {
		return nil, err
	}

	meshes := appmesh_k8s_aws_v1beta2_sets.NewMeshSet()

	configMaps := v1_sets.NewConfigMapSet()
	services := v1_sets.NewServiceSet()
	pods := v1_sets.NewPodSet()
	endpoints := v1_sets.NewEndpointsSet()
	nodes := v1_sets.NewNodeSet()

	deployments := apps_v1_sets.NewDeploymentSet()
	replicaSets := apps_v1_sets.NewReplicaSetSet()
	daemonSets := apps_v1_sets.NewDaemonSetSet()
	statefulSets := apps_v1_sets.NewStatefulSetSet()

	genericSnap.ForEachObject(func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject) {
		switch obj := obj.(type) {
		// insert Meshes
		case *appmesh_k8s_aws_v1beta2_types.Mesh:
			i.insertMesh(ctx, obj, meshes, opts)
		// insert ConfigMaps
		case *v1_types.ConfigMap:
			i.insertConfigMap(ctx, obj, configMaps, opts)
		// insert Services
		case *v1_types.Service:
			i.insertService(ctx, obj, services, opts)
		// insert Pods
		case *v1_types.Pod:
			i.insertPod(ctx, obj, pods, opts)
		// insert Endpoints
		case *v1_types.Endpoints:
			i.insertEndpoints(ctx, obj, endpoints, opts)
		// insert Nodes
		case *v1_types.Node:
			i.insertNode(ctx, obj, nodes, opts)
		// insert Deployments
		case *apps_v1_types.Deployment:
			i.insertDeployment(ctx, obj, deployments, opts)
		// insert ReplicaSets
		case *apps_v1_types.ReplicaSet:
			i.insertReplicaSet(ctx, obj, replicaSets, opts)
		// insert DaemonSets
		case *apps_v1_types.DaemonSet:
			i.insertDaemonSet(ctx, obj, daemonSets, opts)
		// insert StatefulSets
		case *apps_v1_types.StatefulSet:
			i.insertStatefulSet(ctx, obj, statefulSets, opts)
		}
	})

	return NewDiscoveryInputSnapshot(
		name,

		meshes,
		configMaps,
		services,
		pods,
		endpoints,
		nodes,
		deployments,
		replicaSets,
		daemonSets,
		statefulSets,
	), nil
}

func (i *inMemoryDiscoveryInputBuilder) insertMesh(
	ctx context.Context,
	mesh *appmesh_k8s_aws_v1beta2_types.Mesh,
	meshSet appmesh_k8s_aws_v1beta2_sets.MeshSet,
	buildOpts DiscoveryInputBuildOptions,
) {

	opts := buildOpts.Meshes.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = mesh.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(mesh.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		meshSet.Insert(mesh)
	}
}

func (i *inMemoryDiscoveryInputBuilder) insertConfigMap(
	ctx context.Context,
	configMap *v1_types.ConfigMap,
	configMapSet v1_sets.ConfigMapSet,
	buildOpts DiscoveryInputBuildOptions,
) {

	opts := buildOpts.ConfigMaps.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = configMap.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(configMap.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		configMapSet.Insert(configMap)
	}
}
func (i *inMemoryDiscoveryInputBuilder) insertService(
	ctx context.Context,
	service *v1_types.Service,
	serviceSet v1_sets.ServiceSet,
	buildOpts DiscoveryInputBuildOptions,
) {

	opts := buildOpts.Services.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = service.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(service.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		serviceSet.Insert(service)
	}
}
func (i *inMemoryDiscoveryInputBuilder) insertPod(
	ctx context.Context,
	pod *v1_types.Pod,
	podSet v1_sets.PodSet,
	buildOpts DiscoveryInputBuildOptions,
) {

	opts := buildOpts.Pods.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = pod.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(pod.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		podSet.Insert(pod)
	}
}
func (i *inMemoryDiscoveryInputBuilder) insertEndpoints(
	ctx context.Context,
	endpoints *v1_types.Endpoints,
	endpointsSet v1_sets.EndpointsSet,
	buildOpts DiscoveryInputBuildOptions,
) {

	opts := buildOpts.Endpoints.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = endpoints.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(endpoints.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		endpointsSet.Insert(endpoints)
	}
}
func (i *inMemoryDiscoveryInputBuilder) insertNode(
	ctx context.Context,
	node *v1_types.Node,
	nodeSet v1_sets.NodeSet,
	buildOpts DiscoveryInputBuildOptions,
) {

	opts := buildOpts.Nodes.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = node.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(node.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		nodeSet.Insert(node)
	}
}

func (i *inMemoryDiscoveryInputBuilder) insertDeployment(
	ctx context.Context,
	deployment *apps_v1_types.Deployment,
	deploymentSet apps_v1_sets.DeploymentSet,
	buildOpts DiscoveryInputBuildOptions,
) {

	opts := buildOpts.Deployments.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = deployment.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(deployment.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		deploymentSet.Insert(deployment)
	}
}
func (i *inMemoryDiscoveryInputBuilder) insertReplicaSet(
	ctx context.Context,
	replicaSet *apps_v1_types.ReplicaSet,
	replicaSetSet apps_v1_sets.ReplicaSetSet,
	buildOpts DiscoveryInputBuildOptions,
) {

	opts := buildOpts.ReplicaSets.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = replicaSet.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(replicaSet.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		replicaSetSet.Insert(replicaSet)
	}
}
func (i *inMemoryDiscoveryInputBuilder) insertDaemonSet(
	ctx context.Context,
	daemonSet *apps_v1_types.DaemonSet,
	daemonSetSet apps_v1_sets.DaemonSetSet,
	buildOpts DiscoveryInputBuildOptions,
) {

	opts := buildOpts.DaemonSets.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = daemonSet.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(daemonSet.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		daemonSetSet.Insert(daemonSet)
	}
}
func (i *inMemoryDiscoveryInputBuilder) insertStatefulSet(
	ctx context.Context,
	statefulSet *apps_v1_types.StatefulSet,
	statefulSetSet apps_v1_sets.StatefulSetSet,
	buildOpts DiscoveryInputBuildOptions,
) {

	opts := buildOpts.StatefulSets.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = statefulSet.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(statefulSet.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		statefulSetSet.Insert(statefulSet)
	}
}

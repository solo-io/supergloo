// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/service-mesh-hub/api/networking/v1alpha2/virtual_mesh.proto

package v1alpha2

import (
	bytes "bytes"
	fmt "fmt"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	v1 "github.com/solo-io/skv2/pkg/api/core.skv2.solo.io/v1"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//
//If ENABLED, by default disallow traffic to all Services in the VirtualMesh unless explicitly allowed through AccessControlPolicies.
//If DISABLED, by default allow traffic to all Services in the VirtualMesh.
//If MESH_DEFAULT, the default value depends on the type service mesh:
//Istio: false
//Appmesh: true
type VirtualMeshSpec_GlobalAccessPolicy int32

const (
	VirtualMeshSpec_MESH_DEFAULT VirtualMeshSpec_GlobalAccessPolicy = 0
	VirtualMeshSpec_ENABLED      VirtualMeshSpec_GlobalAccessPolicy = 1
	VirtualMeshSpec_DISABLED     VirtualMeshSpec_GlobalAccessPolicy = 2
)

var VirtualMeshSpec_GlobalAccessPolicy_name = map[int32]string{
	0: "MESH_DEFAULT",
	1: "ENABLED",
	2: "DISABLED",
}

var VirtualMeshSpec_GlobalAccessPolicy_value = map[string]int32{
	"MESH_DEFAULT": 0,
	"ENABLED":      1,
	"DISABLED":     2,
}

func (x VirtualMeshSpec_GlobalAccessPolicy) String() string {
	return proto.EnumName(VirtualMeshSpec_GlobalAccessPolicy_name, int32(x))
}

func (VirtualMeshSpec_GlobalAccessPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8ec20aa69a8d951, []int{0, 0}
}

// A VirtualMesh represents a logical grouping of meshes for
// shared configuration and cross-mesh interoperability.
//
// VirtualMeshes are used to configure things like shared trust roots (for mTLS)
// and federation of services (for cross-cluster networking).
//
// Currently, VirtualMeshes can only be constructed from Istio
// meshes.
type VirtualMeshSpec struct {
	// The meshes contained in this virtual mesh.
	Meshes []*v1.ObjectRef `protobuf:"bytes,1,rep,name=meshes,proto3" json:"meshes,omitempty"`
	// Configuration options for managing Mutual-TLS mTLS in a virtual mesh.Sets
	// a shared Certificate Authority across the defined meshes.
	MtlsConfig *VirtualMeshSpec_MTLSConfig `protobuf:"bytes,2,opt,name=mtls_config,json=mtlsConfig,proto3" json:"mtls_config,omitempty"`
	// Determine how to expose services to cross-mesh traffic using Service Federation.
	Federation *VirtualMeshSpec_Federation `protobuf:"bytes,3,opt,name=federation,proto3" json:"federation,omitempty"`
	// Sets an Access Policy for the whole mesh.
	GlobalAccessPolicy   VirtualMeshSpec_GlobalAccessPolicy `protobuf:"varint,4,opt,name=global_access_policy,json=globalAccessPolicy,proto3,enum=networking.smh.solo.io.VirtualMeshSpec_GlobalAccessPolicy" json:"global_access_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *VirtualMeshSpec) Reset()         { *m = VirtualMeshSpec{} }
func (m *VirtualMeshSpec) String() string { return proto.CompactTextString(m) }
func (*VirtualMeshSpec) ProtoMessage()    {}
func (*VirtualMeshSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8ec20aa69a8d951, []int{0}
}
func (m *VirtualMeshSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualMeshSpec.Unmarshal(m, b)
}
func (m *VirtualMeshSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualMeshSpec.Marshal(b, m, deterministic)
}
func (m *VirtualMeshSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualMeshSpec.Merge(m, src)
}
func (m *VirtualMeshSpec) XXX_Size() int {
	return xxx_messageInfo_VirtualMeshSpec.Size(m)
}
func (m *VirtualMeshSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualMeshSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualMeshSpec proto.InternalMessageInfo

func (m *VirtualMeshSpec) GetMeshes() []*v1.ObjectRef {
	if m != nil {
		return m.Meshes
	}
	return nil
}

func (m *VirtualMeshSpec) GetMtlsConfig() *VirtualMeshSpec_MTLSConfig {
	if m != nil {
		return m.MtlsConfig
	}
	return nil
}

func (m *VirtualMeshSpec) GetFederation() *VirtualMeshSpec_Federation {
	if m != nil {
		return m.Federation
	}
	return nil
}

func (m *VirtualMeshSpec) GetGlobalAccessPolicy() VirtualMeshSpec_GlobalAccessPolicy {
	if m != nil {
		return m.GlobalAccessPolicy
	}
	return VirtualMeshSpec_MESH_DEFAULT
}

// Mutual TLS Config for a Virtual Mesh.
// This includes options for configuring Mutual TLS within an indvidual mesh, as
// well as enabling mTLS across Meshes by establishing cross-mesh trust.
type VirtualMeshSpec_MTLSConfig struct {
	// Select a trust model in order to establish trust between mTLS-secured meshes.
	//
	// Types that are valid to be assigned to TrustModel:
	//	*VirtualMeshSpec_MTLSConfig_Shared
	//	*VirtualMeshSpec_MTLSConfig_Limited
	TrustModel           isVirtualMeshSpec_MTLSConfig_TrustModel `protobuf_oneof:"trust_model"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *VirtualMeshSpec_MTLSConfig) Reset()         { *m = VirtualMeshSpec_MTLSConfig{} }
func (m *VirtualMeshSpec_MTLSConfig) String() string { return proto.CompactTextString(m) }
func (*VirtualMeshSpec_MTLSConfig) ProtoMessage()    {}
func (*VirtualMeshSpec_MTLSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8ec20aa69a8d951, []int{0, 0}
}
func (m *VirtualMeshSpec_MTLSConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualMeshSpec_MTLSConfig.Unmarshal(m, b)
}
func (m *VirtualMeshSpec_MTLSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualMeshSpec_MTLSConfig.Marshal(b, m, deterministic)
}
func (m *VirtualMeshSpec_MTLSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualMeshSpec_MTLSConfig.Merge(m, src)
}
func (m *VirtualMeshSpec_MTLSConfig) XXX_Size() int {
	return xxx_messageInfo_VirtualMeshSpec_MTLSConfig.Size(m)
}
func (m *VirtualMeshSpec_MTLSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualMeshSpec_MTLSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualMeshSpec_MTLSConfig proto.InternalMessageInfo

type isVirtualMeshSpec_MTLSConfig_TrustModel interface {
	isVirtualMeshSpec_MTLSConfig_TrustModel()
	Equal(interface{}) bool
}

type VirtualMeshSpec_MTLSConfig_Shared struct {
	Shared *VirtualMeshSpec_MTLSConfig_SharedTrust `protobuf:"bytes,1,opt,name=shared,proto3,oneof" json:"shared,omitempty"`
}
type VirtualMeshSpec_MTLSConfig_Limited struct {
	Limited *VirtualMeshSpec_MTLSConfig_LimitedTrust `protobuf:"bytes,2,opt,name=limited,proto3,oneof" json:"limited,omitempty"`
}

func (*VirtualMeshSpec_MTLSConfig_Shared) isVirtualMeshSpec_MTLSConfig_TrustModel()  {}
func (*VirtualMeshSpec_MTLSConfig_Limited) isVirtualMeshSpec_MTLSConfig_TrustModel() {}

func (m *VirtualMeshSpec_MTLSConfig) GetTrustModel() isVirtualMeshSpec_MTLSConfig_TrustModel {
	if m != nil {
		return m.TrustModel
	}
	return nil
}

func (m *VirtualMeshSpec_MTLSConfig) GetShared() *VirtualMeshSpec_MTLSConfig_SharedTrust {
	if x, ok := m.GetTrustModel().(*VirtualMeshSpec_MTLSConfig_Shared); ok {
		return x.Shared
	}
	return nil
}

func (m *VirtualMeshSpec_MTLSConfig) GetLimited() *VirtualMeshSpec_MTLSConfig_LimitedTrust {
	if x, ok := m.GetTrustModel().(*VirtualMeshSpec_MTLSConfig_Limited); ok {
		return x.Limited
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VirtualMeshSpec_MTLSConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VirtualMeshSpec_MTLSConfig_Shared)(nil),
		(*VirtualMeshSpec_MTLSConfig_Limited)(nil),
	}
}

//
//Shared trust is a virtual mesh trust model requiring a shared root certificate, as well as shared identity
//between all entities which wish to communicate within the virtual mesh.
//
//The best current example of this would be the replicated control planes example from Istio:
//https://preliminary.istio.io/docs/setup/install/multicluster/gateways/
type VirtualMeshSpec_MTLSConfig_SharedTrust struct {
	// Configure a Root Certificate Authority which will be shared by the
	// members of the virtual mesh.
	// If this is not provided, a self-signed certificate will be used
	// by Service Mesh Hub to establish shared trust for the purposes of failover and federation.
	RootCertificateAuthority *VirtualMeshSpec_RootCertificateAuthority `protobuf:"bytes,1,opt,name=root_certificate_authority,json=rootCertificateAuthority,proto3" json:"root_certificate_authority,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                                  `json:"-"`
	XXX_unrecognized         []byte                                    `json:"-"`
	XXX_sizecache            int32                                     `json:"-"`
}

func (m *VirtualMeshSpec_MTLSConfig_SharedTrust) Reset() {
	*m = VirtualMeshSpec_MTLSConfig_SharedTrust{}
}
func (m *VirtualMeshSpec_MTLSConfig_SharedTrust) String() string { return proto.CompactTextString(m) }
func (*VirtualMeshSpec_MTLSConfig_SharedTrust) ProtoMessage()    {}
func (*VirtualMeshSpec_MTLSConfig_SharedTrust) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8ec20aa69a8d951, []int{0, 0, 0}
}
func (m *VirtualMeshSpec_MTLSConfig_SharedTrust) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualMeshSpec_MTLSConfig_SharedTrust.Unmarshal(m, b)
}
func (m *VirtualMeshSpec_MTLSConfig_SharedTrust) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualMeshSpec_MTLSConfig_SharedTrust.Marshal(b, m, deterministic)
}
func (m *VirtualMeshSpec_MTLSConfig_SharedTrust) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualMeshSpec_MTLSConfig_SharedTrust.Merge(m, src)
}
func (m *VirtualMeshSpec_MTLSConfig_SharedTrust) XXX_Size() int {
	return xxx_messageInfo_VirtualMeshSpec_MTLSConfig_SharedTrust.Size(m)
}
func (m *VirtualMeshSpec_MTLSConfig_SharedTrust) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualMeshSpec_MTLSConfig_SharedTrust.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualMeshSpec_MTLSConfig_SharedTrust proto.InternalMessageInfo

func (m *VirtualMeshSpec_MTLSConfig_SharedTrust) GetRootCertificateAuthority() *VirtualMeshSpec_RootCertificateAuthority {
	if m != nil {
		return m.RootCertificateAuthority
	}
	return nil
}

//
//Limited trust is a virtual mesh trust model which does not require all meshes sharing the same root certificate
//or identity model. But rather, the limited trust creates trust between meshes running on different clusters
//by connecting their ingress/egress gateways with a common cert/identity. In this model all requests
//between different have the following request path when communicating between clusters
//
//cluster 1 MTLS               shared MTLS                  cluster 2 MTLS
//client/workload <-----------> egress gateway <----------> ingress gateway <--------------> server
//
//This approach has the downside of not maintaining identity from client to server, but allows for ad-hoc
//addition of additional clusters into a virtual mesh.
type VirtualMeshSpec_MTLSConfig_LimitedTrust struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualMeshSpec_MTLSConfig_LimitedTrust) Reset() {
	*m = VirtualMeshSpec_MTLSConfig_LimitedTrust{}
}
func (m *VirtualMeshSpec_MTLSConfig_LimitedTrust) String() string { return proto.CompactTextString(m) }
func (*VirtualMeshSpec_MTLSConfig_LimitedTrust) ProtoMessage()    {}
func (*VirtualMeshSpec_MTLSConfig_LimitedTrust) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8ec20aa69a8d951, []int{0, 0, 1}
}
func (m *VirtualMeshSpec_MTLSConfig_LimitedTrust) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualMeshSpec_MTLSConfig_LimitedTrust.Unmarshal(m, b)
}
func (m *VirtualMeshSpec_MTLSConfig_LimitedTrust) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualMeshSpec_MTLSConfig_LimitedTrust.Marshal(b, m, deterministic)
}
func (m *VirtualMeshSpec_MTLSConfig_LimitedTrust) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualMeshSpec_MTLSConfig_LimitedTrust.Merge(m, src)
}
func (m *VirtualMeshSpec_MTLSConfig_LimitedTrust) XXX_Size() int {
	return xxx_messageInfo_VirtualMeshSpec_MTLSConfig_LimitedTrust.Size(m)
}
func (m *VirtualMeshSpec_MTLSConfig_LimitedTrust) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualMeshSpec_MTLSConfig_LimitedTrust.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualMeshSpec_MTLSConfig_LimitedTrust proto.InternalMessageInfo

// RootCertificateAuthority defines parameters for configuring the
// root CA for a Virtual Mesh.
type VirtualMeshSpec_RootCertificateAuthority struct {
	// Select a source for the Root CA data which Service Mesh Hub will use for the Virtual Mesh.
	//
	// Types that are valid to be assigned to CaSource:
	//	*VirtualMeshSpec_RootCertificateAuthority_Generated
	//	*VirtualMeshSpec_RootCertificateAuthority_Secret
	CaSource             isVirtualMeshSpec_RootCertificateAuthority_CaSource `protobuf_oneof:"ca_source"`
	XXX_NoUnkeyedLiteral struct{}                                            `json:"-"`
	XXX_unrecognized     []byte                                              `json:"-"`
	XXX_sizecache        int32                                               `json:"-"`
}

func (m *VirtualMeshSpec_RootCertificateAuthority) Reset() {
	*m = VirtualMeshSpec_RootCertificateAuthority{}
}
func (m *VirtualMeshSpec_RootCertificateAuthority) String() string { return proto.CompactTextString(m) }
func (*VirtualMeshSpec_RootCertificateAuthority) ProtoMessage()    {}
func (*VirtualMeshSpec_RootCertificateAuthority) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8ec20aa69a8d951, []int{0, 1}
}
func (m *VirtualMeshSpec_RootCertificateAuthority) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority.Unmarshal(m, b)
}
func (m *VirtualMeshSpec_RootCertificateAuthority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority.Marshal(b, m, deterministic)
}
func (m *VirtualMeshSpec_RootCertificateAuthority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority.Merge(m, src)
}
func (m *VirtualMeshSpec_RootCertificateAuthority) XXX_Size() int {
	return xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority.Size(m)
}
func (m *VirtualMeshSpec_RootCertificateAuthority) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority proto.InternalMessageInfo

type isVirtualMeshSpec_RootCertificateAuthority_CaSource interface {
	isVirtualMeshSpec_RootCertificateAuthority_CaSource()
	Equal(interface{}) bool
}

type VirtualMeshSpec_RootCertificateAuthority_Generated struct {
	Generated *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert `protobuf:"bytes,1,opt,name=generated,proto3,oneof" json:"generated,omitempty"`
}
type VirtualMeshSpec_RootCertificateAuthority_Secret struct {
	Secret *v1.ObjectRef `protobuf:"bytes,2,opt,name=secret,proto3,oneof" json:"secret,omitempty"`
}

func (*VirtualMeshSpec_RootCertificateAuthority_Generated) isVirtualMeshSpec_RootCertificateAuthority_CaSource() {
}
func (*VirtualMeshSpec_RootCertificateAuthority_Secret) isVirtualMeshSpec_RootCertificateAuthority_CaSource() {
}

func (m *VirtualMeshSpec_RootCertificateAuthority) GetCaSource() isVirtualMeshSpec_RootCertificateAuthority_CaSource {
	if m != nil {
		return m.CaSource
	}
	return nil
}

func (m *VirtualMeshSpec_RootCertificateAuthority) GetGenerated() *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert {
	if x, ok := m.GetCaSource().(*VirtualMeshSpec_RootCertificateAuthority_Generated); ok {
		return x.Generated
	}
	return nil
}

func (m *VirtualMeshSpec_RootCertificateAuthority) GetSecret() *v1.ObjectRef {
	if x, ok := m.GetCaSource().(*VirtualMeshSpec_RootCertificateAuthority_Secret); ok {
		return x.Secret
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VirtualMeshSpec_RootCertificateAuthority) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VirtualMeshSpec_RootCertificateAuthority_Generated)(nil),
		(*VirtualMeshSpec_RootCertificateAuthority_Secret)(nil),
	}
}

//
//Configuration for generating a self-signed root certificate.
//Uses the X.509 format, RFC5280
type VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert struct {
	// Number of days before root cert expires. Defaults to 365.
	TtlDays uint32 `protobuf:"varint,1,opt,name=ttl_days,json=ttlDays,proto3" json:"ttl_days,omitempty"`
	// Size in bytes of the root cert's private key. Defaults to 4096
	RsaKeySizeBytes uint32 `protobuf:"varint,2,opt,name=rsa_key_size_bytes,json=rsaKeySizeBytes,proto3" json:"rsa_key_size_bytes,omitempty"`
	// Root cert organization name. Defaults to "service-mesh-hub"
	OrgName              string   `protobuf:"bytes,3,opt,name=org_name,json=orgName,proto3" json:"org_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) Reset() {
	*m = VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert{}
}
func (m *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) String() string {
	return proto.CompactTextString(m)
}
func (*VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) ProtoMessage() {}
func (*VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8ec20aa69a8d951, []int{0, 1, 0}
}
func (m *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert.Unmarshal(m, b)
}
func (m *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert.Marshal(b, m, deterministic)
}
func (m *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert.Merge(m, src)
}
func (m *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) XXX_Size() int {
	return xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert.Size(m)
}
func (m *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert proto.InternalMessageInfo

func (m *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) GetTtlDays() uint32 {
	if m != nil {
		return m.TtlDays
	}
	return 0
}

func (m *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) GetRsaKeySizeBytes() uint32 {
	if m != nil {
		return m.RsaKeySizeBytes
	}
	return 0
}

func (m *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) GetOrgName() string {
	if m != nil {
		return m.OrgName
	}
	return ""
}

// In Service Mesh Hub, Federation refers to the ability
// to expose services on with a global DNS name
// for traffic originating from any service within the
// virtual mesh.
type VirtualMeshSpec_Federation struct {
	// The "mode" in which to federate services within this virtual mesh.
	//
	// Types that are valid to be assigned to Mode:
	//	*VirtualMeshSpec_Federation_Permissive
	Mode                 isVirtualMeshSpec_Federation_Mode `protobuf_oneof:"mode"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *VirtualMeshSpec_Federation) Reset()         { *m = VirtualMeshSpec_Federation{} }
func (m *VirtualMeshSpec_Federation) String() string { return proto.CompactTextString(m) }
func (*VirtualMeshSpec_Federation) ProtoMessage()    {}
func (*VirtualMeshSpec_Federation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8ec20aa69a8d951, []int{0, 2}
}
func (m *VirtualMeshSpec_Federation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualMeshSpec_Federation.Unmarshal(m, b)
}
func (m *VirtualMeshSpec_Federation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualMeshSpec_Federation.Marshal(b, m, deterministic)
}
func (m *VirtualMeshSpec_Federation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualMeshSpec_Federation.Merge(m, src)
}
func (m *VirtualMeshSpec_Federation) XXX_Size() int {
	return xxx_messageInfo_VirtualMeshSpec_Federation.Size(m)
}
func (m *VirtualMeshSpec_Federation) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualMeshSpec_Federation.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualMeshSpec_Federation proto.InternalMessageInfo

type isVirtualMeshSpec_Federation_Mode interface {
	isVirtualMeshSpec_Federation_Mode()
	Equal(interface{}) bool
}

type VirtualMeshSpec_Federation_Permissive struct {
	Permissive *types.Empty `protobuf:"bytes,1,opt,name=permissive,proto3,oneof" json:"permissive,omitempty"`
}

func (*VirtualMeshSpec_Federation_Permissive) isVirtualMeshSpec_Federation_Mode() {}

func (m *VirtualMeshSpec_Federation) GetMode() isVirtualMeshSpec_Federation_Mode {
	if m != nil {
		return m.Mode
	}
	return nil
}

func (m *VirtualMeshSpec_Federation) GetPermissive() *types.Empty {
	if x, ok := m.GetMode().(*VirtualMeshSpec_Federation_Permissive); ok {
		return x.Permissive
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VirtualMeshSpec_Federation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VirtualMeshSpec_Federation_Permissive)(nil),
	}
}

type VirtualMeshStatus struct {
	// The most recent generation observed in the the TrafficPolicy metadata.
	// if the observedGeneration does not match generation, the controller has not received the most
	// recent version of this resource.
	ObservedGeneration int64 `protobuf:"varint,1,opt,name=observed_generation,json=observedGeneration,proto3" json:"observed_generation,omitempty"`
	// the state of the overall resource.
	// will only show accepted if it has been successfully
	// applied to all target meshes.
	State ApprovalState `protobuf:"varint,2,opt,name=state,proto3,enum=networking.smh.solo.io.ApprovalState" json:"state,omitempty"`
	// The status of the VirtualMesh for each Mesh to which it has been applied.
	// A TrafficPolicy may be Accepted for some Meshes and rejected for others.
	Meshes               map[string]*ApprovalStatus `protobuf:"bytes,3,rep,name=meshes,proto3" json:"meshes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *VirtualMeshStatus) Reset()         { *m = VirtualMeshStatus{} }
func (m *VirtualMeshStatus) String() string { return proto.CompactTextString(m) }
func (*VirtualMeshStatus) ProtoMessage()    {}
func (*VirtualMeshStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8ec20aa69a8d951, []int{1}
}
func (m *VirtualMeshStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualMeshStatus.Unmarshal(m, b)
}
func (m *VirtualMeshStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualMeshStatus.Marshal(b, m, deterministic)
}
func (m *VirtualMeshStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualMeshStatus.Merge(m, src)
}
func (m *VirtualMeshStatus) XXX_Size() int {
	return xxx_messageInfo_VirtualMeshStatus.Size(m)
}
func (m *VirtualMeshStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualMeshStatus.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualMeshStatus proto.InternalMessageInfo

func (m *VirtualMeshStatus) GetObservedGeneration() int64 {
	if m != nil {
		return m.ObservedGeneration
	}
	return 0
}

func (m *VirtualMeshStatus) GetState() ApprovalState {
	if m != nil {
		return m.State
	}
	return ApprovalState_PENDING
}

func (m *VirtualMeshStatus) GetMeshes() map[string]*ApprovalStatus {
	if m != nil {
		return m.Meshes
	}
	return nil
}

func init() {
	proto.RegisterEnum("networking.smh.solo.io.VirtualMeshSpec_GlobalAccessPolicy", VirtualMeshSpec_GlobalAccessPolicy_name, VirtualMeshSpec_GlobalAccessPolicy_value)
	proto.RegisterType((*VirtualMeshSpec)(nil), "networking.smh.solo.io.VirtualMeshSpec")
	proto.RegisterType((*VirtualMeshSpec_MTLSConfig)(nil), "networking.smh.solo.io.VirtualMeshSpec.MTLSConfig")
	proto.RegisterType((*VirtualMeshSpec_MTLSConfig_SharedTrust)(nil), "networking.smh.solo.io.VirtualMeshSpec.MTLSConfig.SharedTrust")
	proto.RegisterType((*VirtualMeshSpec_MTLSConfig_LimitedTrust)(nil), "networking.smh.solo.io.VirtualMeshSpec.MTLSConfig.LimitedTrust")
	proto.RegisterType((*VirtualMeshSpec_RootCertificateAuthority)(nil), "networking.smh.solo.io.VirtualMeshSpec.RootCertificateAuthority")
	proto.RegisterType((*VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert)(nil), "networking.smh.solo.io.VirtualMeshSpec.RootCertificateAuthority.SelfSignedCert")
	proto.RegisterType((*VirtualMeshSpec_Federation)(nil), "networking.smh.solo.io.VirtualMeshSpec.Federation")
	proto.RegisterType((*VirtualMeshStatus)(nil), "networking.smh.solo.io.VirtualMeshStatus")
	proto.RegisterMapType((map[string]*ApprovalStatus)(nil), "networking.smh.solo.io.VirtualMeshStatus.MeshesEntry")
}

func init() {
	proto.RegisterFile("github.com/solo-io/service-mesh-hub/api/networking/v1alpha2/virtual_mesh.proto", fileDescriptor_d8ec20aa69a8d951)
}

var fileDescriptor_d8ec20aa69a8d951 = []byte{
	// 843 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x95, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0x80, 0x63, 0xa7, 0x75, 0xea, 0xe3, 0x24, 0x0d, 0x43, 0x55, 0x99, 0x05, 0x55, 0x51, 0x24,
	0x50, 0x24, 0x94, 0x5d, 0xd5, 0xfc, 0xa8, 0x2a, 0x88, 0x62, 0x37, 0x6e, 0x83, 0x1a, 0xa7, 0x30,
	0x1b, 0x10, 0x82, 0x8b, 0xd5, 0x78, 0x7d, 0xbc, 0x1e, 0x3c, 0xeb, 0x59, 0xcd, 0xcc, 0xba, 0xda,
	0x5e, 0xf0, 0x06, 0xbc, 0x07, 0x57, 0xdc, 0xf0, 0x0c, 0xbc, 0x08, 0x8f, 0xc0, 0x13, 0xa0, 0x99,
	0x5d, 0xff, 0x90, 0x36, 0xc8, 0x85, 0xab, 0x9d, 0x9d, 0x33, 0xe7, 0x3b, 0x7f, 0x73, 0xce, 0xc0,
	0x45, 0xc2, 0xcd, 0x24, 0x1f, 0xfa, 0xb1, 0x4c, 0x03, 0x2d, 0x85, 0x3c, 0xe1, 0x32, 0xd0, 0xa8,
	0xe6, 0x3c, 0xc6, 0x93, 0x14, 0xf5, 0xe4, 0x64, 0x92, 0x0f, 0x03, 0x96, 0xf1, 0x60, 0x86, 0xe6,
	0x85, 0x54, 0x53, 0x3e, 0x4b, 0x82, 0xf9, 0x7d, 0x26, 0xb2, 0x09, 0xeb, 0x04, 0x73, 0xae, 0x4c,
	0xce, 0x44, 0x64, 0x0f, 0xfa, 0x99, 0x92, 0x46, 0x92, 0xbb, 0xab, 0x73, 0xbe, 0x4e, 0x27, 0xbe,
	0x65, 0xfa, 0x5c, 0x7a, 0xfe, 0xeb, 0xec, 0x4c, 0xe7, 0x1d, 0xc7, 0x8e, 0xa5, 0xc2, 0x60, 0x7e,
	0xdf, 0x7d, 0x4b, 0x8e, 0xf7, 0x68, 0x73, 0x27, 0x98, 0xe0, 0x23, 0x66, 0xb8, 0x9c, 0x45, 0xda,
	0x30, 0xb3, 0x00, 0xbc, 0x9b, 0x48, 0x99, 0x08, 0x0c, 0xdc, 0xdf, 0x30, 0x1f, 0x07, 0x98, 0x66,
	0xa6, 0xa8, 0x84, 0xf7, 0xae, 0x0a, 0x5f, 0x28, 0x96, 0x65, 0xa8, 0x74, 0x25, 0xbf, 0x93, 0xc8,
	0x44, 0xba, 0x65, 0x60, 0x57, 0xe5, 0xee, 0xd1, 0x6f, 0x4d, 0xb8, 0xfd, 0x5d, 0x19, 0xf2, 0x00,
	0xf5, 0x24, 0xcc, 0x30, 0x26, 0x1f, 0x43, 0xc3, 0x7a, 0x88, 0xba, 0x5d, 0x3b, 0xdc, 0x3e, 0x6e,
	0x75, 0xde, 0xf3, 0x5d, 0x10, 0x36, 0xb4, 0x45, 0xec, 0xfe, 0xf3, 0xe1, 0x4f, 0x18, 0x1b, 0x8a,
	0x63, 0x5a, 0x9d, 0x25, 0x21, 0xb4, 0x52, 0x23, 0x74, 0x14, 0xcb, 0xd9, 0x98, 0x27, 0xed, 0xfa,
	0x61, 0xed, 0xb8, 0xd5, 0xe9, 0xf8, 0xaf, 0xcf, 0x9d, 0x7f, 0xc5, 0xa6, 0x3f, 0xb8, 0x3c, 0x0f,
	0x1f, 0x3b, 0x4d, 0x0a, 0x16, 0x53, 0xae, 0x09, 0x05, 0x18, 0xe3, 0x08, 0x95, 0xcb, 0x45, 0x7b,
	0xfb, 0xcd, 0x98, 0x4f, 0x96, 0x9a, 0x74, 0x8d, 0x42, 0x04, 0xdc, 0x49, 0x84, 0x1c, 0x32, 0x11,
	0xb1, 0x38, 0x46, 0xad, 0xa3, 0x4c, 0x0a, 0x1e, 0x17, 0xed, 0x1b, 0x87, 0xb5, 0xe3, 0xfd, 0xce,
	0xc3, 0x4d, 0xe9, 0x4f, 0x1d, 0xa3, 0xeb, 0x10, 0x5f, 0x3b, 0x02, 0x25, 0xc9, 0x2b, 0x7b, 0xde,
	0x5f, 0x75, 0x80, 0x55, 0x70, 0xe4, 0x7b, 0x68, 0xe8, 0x09, 0x53, 0x38, 0x6a, 0xd7, 0x5c, 0x30,
	0x5f, 0xbc, 0x79, 0x82, 0xfc, 0xd0, 0x01, 0x2e, 0x55, 0xae, 0xcd, 0xd9, 0x16, 0xad, 0x78, 0xe4,
	0x47, 0xd8, 0x11, 0x3c, 0xe5, 0x06, 0x47, 0x55, 0xee, 0x1f, 0xfd, 0x07, 0xf4, 0x79, 0x49, 0x58,
	0xb0, 0x17, 0x44, 0xef, 0x97, 0x1a, 0xb4, 0xd6, 0xcc, 0x92, 0x9f, 0xc1, 0x53, 0x52, 0x9a, 0x28,
	0x46, 0x65, 0xf8, 0x98, 0xc7, 0xcc, 0x60, 0xc4, 0x72, 0x33, 0x91, 0x8a, 0x9b, 0xa2, 0x0a, 0xed,
	0xcb, 0x4d, 0xed, 0x53, 0x29, 0xcd, 0xe3, 0x15, 0xa8, 0xbb, 0xe0, 0xd0, 0xb6, 0xba, 0x46, 0xe2,
	0xed, 0xc3, 0xee, 0xba, 0xab, 0xbd, 0x3d, 0x68, 0x19, 0xbb, 0x88, 0x52, 0x39, 0x42, 0xe1, 0xfd,
	0x51, 0x87, 0xf6, 0x75, 0x54, 0x22, 0xa1, 0x99, 0xe0, 0xcc, 0xde, 0x86, 0x65, 0x15, 0x9e, 0xff,
	0x5f, 0x57, 0xfd, 0x10, 0xc5, 0x38, 0xe4, 0xc9, 0x0c, 0x47, 0x56, 0x7c, 0xb6, 0x45, 0x57, 0x36,
	0xc8, 0xa7, 0xd0, 0xd0, 0x18, 0x2b, 0x34, 0x55, 0x61, 0xfe, 0xb5, 0x9f, 0x5c, 0x45, 0xdd, 0x69,
	0x4f, 0xc3, 0xfe, 0x3f, 0xb1, 0xe4, 0x1d, 0xb8, 0x65, 0x8c, 0x88, 0x46, 0xac, 0xd0, 0xce, 0xf3,
	0x3d, 0xba, 0x63, 0x8c, 0x38, 0x65, 0x85, 0x26, 0x1f, 0x02, 0x51, 0x9a, 0x45, 0x53, 0x2c, 0x22,
	0xcd, 0x5f, 0x62, 0x34, 0x2c, 0x0c, 0x6a, 0x67, 0x70, 0x8f, 0xde, 0x56, 0x9a, 0x3d, 0xc3, 0x22,
	0xe4, 0x2f, 0xb1, 0x67, 0xb7, 0x2d, 0x47, 0xaa, 0x24, 0x9a, 0xb1, 0x14, 0x5d, 0x53, 0x35, 0xe9,
	0x8e, 0x54, 0xc9, 0x05, 0x4b, 0xb1, 0xd7, 0x82, 0x66, 0xcc, 0x22, 0x2d, 0x73, 0x15, 0xa3, 0x77,
	0x01, 0xb0, 0x6a, 0x22, 0xf2, 0x00, 0x20, 0x43, 0x95, 0x72, 0xad, 0xf9, 0x1c, 0xab, 0xcc, 0xdd,
	0xf5, 0xcb, 0xb1, 0xe3, 0x2f, 0xc6, 0x8e, 0xdf, 0xb7, 0x33, 0xe9, 0x6c, 0x8b, 0xae, 0x9d, 0xed,
	0x35, 0xe0, 0x86, 0x2d, 0xcc, 0x51, 0x17, 0xc8, 0xab, 0x6d, 0x43, 0x0e, 0x60, 0x77, 0xd0, 0x0f,
	0xcf, 0xa2, 0xd3, 0xfe, 0x93, 0xee, 0xb7, 0xe7, 0x97, 0x07, 0x5b, 0xa4, 0x05, 0x3b, 0xfd, 0x8b,
	0x6e, 0xef, 0xbc, 0x7f, 0x7a, 0x50, 0x23, 0xbb, 0x70, 0xeb, 0xf4, 0xab, 0xb0, 0xfc, 0xab, 0x1f,
	0xfd, 0x5e, 0x87, 0xb7, 0xd6, 0xab, 0x62, 0x98, 0xc9, 0x35, 0x09, 0xe0, 0x6d, 0x39, 0xb4, 0xe3,
	0x15, 0x47, 0x51, 0x95, 0x78, 0x3b, 0x30, 0xac, 0x8f, 0xdb, 0x94, 0x2c, 0x44, 0x4f, 0x97, 0x12,
	0xf2, 0x19, 0xdc, 0x74, 0x93, 0xd5, 0x65, 0x68, 0xbf, 0xf3, 0xfe, 0x75, 0x17, 0xa0, 0x9b, 0x65,
	0x4a, 0xce, 0x99, 0xb0, 0x76, 0x90, 0x96, 0x3a, 0x64, 0xb0, 0x1c, 0x90, 0xdb, 0x6e, 0x40, 0x7e,
	0xb2, 0xc9, 0xf5, 0x71, 0x8e, 0xfa, 0x03, 0xa7, 0xd7, 0x9f, 0x19, 0x55, 0x2c, 0x26, 0xa7, 0xc7,
	0xa0, 0xb5, 0xb6, 0x4d, 0x0e, 0x60, 0x7b, 0x8a, 0x65, 0x13, 0x35, 0xa9, 0x5d, 0x92, 0xcf, 0xe1,
	0xe6, 0x9c, 0x89, 0x1c, 0xab, 0xfb, 0xf3, 0xc1, 0x26, 0xce, 0xe6, 0x9a, 0x96, 0x4a, 0x0f, 0xeb,
	0x0f, 0x6a, 0xbd, 0x6f, 0x7e, 0xfd, 0xf3, 0x5e, 0xed, 0x87, 0x67, 0x9b, 0x3c, 0x8c, 0xd9, 0x34,
	0xb9, 0xf2, 0x2e, 0xad, 0xdb, 0x58, 0xbe, 0x51, 0xc3, 0x86, 0xab, 0xf8, 0x47, 0x7f, 0x07, 0x00,
	0x00, 0xff, 0xff, 0xfa, 0x26, 0xf1, 0x5b, 0x6e, 0x07, 0x00, 0x00,
}

func (this *VirtualMeshSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec)
	if !ok {
		that2, ok := that.(VirtualMeshSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Meshes) != len(that1.Meshes) {
		return false
	}
	for i := range this.Meshes {
		if !this.Meshes[i].Equal(that1.Meshes[i]) {
			return false
		}
	}
	if !this.MtlsConfig.Equal(that1.MtlsConfig) {
		return false
	}
	if !this.Federation.Equal(that1.Federation) {
		return false
	}
	if this.GlobalAccessPolicy != that1.GlobalAccessPolicy {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_MTLSConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_MTLSConfig)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_MTLSConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.TrustModel == nil {
		if this.TrustModel != nil {
			return false
		}
	} else if this.TrustModel == nil {
		return false
	} else if !this.TrustModel.Equal(that1.TrustModel) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_MTLSConfig_Shared) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_MTLSConfig_Shared)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_MTLSConfig_Shared)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Shared.Equal(that1.Shared) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_MTLSConfig_Limited) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_MTLSConfig_Limited)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_MTLSConfig_Limited)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Limited.Equal(that1.Limited) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_MTLSConfig_SharedTrust) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_MTLSConfig_SharedTrust)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_MTLSConfig_SharedTrust)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RootCertificateAuthority.Equal(that1.RootCertificateAuthority) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_MTLSConfig_LimitedTrust) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_MTLSConfig_LimitedTrust)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_MTLSConfig_LimitedTrust)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_RootCertificateAuthority) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_RootCertificateAuthority)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_RootCertificateAuthority)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CaSource == nil {
		if this.CaSource != nil {
			return false
		}
	} else if this.CaSource == nil {
		return false
	} else if !this.CaSource.Equal(that1.CaSource) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_RootCertificateAuthority_Generated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_RootCertificateAuthority_Generated)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_RootCertificateAuthority_Generated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Generated.Equal(that1.Generated) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_RootCertificateAuthority_Secret) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_RootCertificateAuthority_Secret)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_RootCertificateAuthority_Secret)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Secret.Equal(that1.Secret) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_RootCertificateAuthority_SelfSignedCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TtlDays != that1.TtlDays {
		return false
	}
	if this.RsaKeySizeBytes != that1.RsaKeySizeBytes {
		return false
	}
	if this.OrgName != that1.OrgName {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_Federation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_Federation)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_Federation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Mode == nil {
		if this.Mode != nil {
			return false
		}
	} else if this.Mode == nil {
		return false
	} else if !this.Mode.Equal(that1.Mode) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VirtualMeshSpec_Federation_Permissive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshSpec_Federation_Permissive)
	if !ok {
		that2, ok := that.(VirtualMeshSpec_Federation_Permissive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Permissive.Equal(that1.Permissive) {
		return false
	}
	return true
}
func (this *VirtualMeshStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualMeshStatus)
	if !ok {
		that2, ok := that.(VirtualMeshStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ObservedGeneration != that1.ObservedGeneration {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if len(this.Meshes) != len(that1.Meshes) {
		return false
	}
	for i := range this.Meshes {
		if !this.Meshes[i].Equal(that1.Meshes[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

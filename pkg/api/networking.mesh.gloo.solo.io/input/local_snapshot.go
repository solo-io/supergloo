// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./local_snapshot.go -destination mocks/local_snapshot.go

// The Input LocalSnapshot contains the set of all:
// * Settings
// * TrafficTargets
// * Workloads
// * Meshes
// * TrafficPolicies
// * AccessPolicies
// * VirtualMeshes
// * FailoverServices
// * WasmDeployments
// * AccessLogCollections
// * Secrets
// * KubernetesClusters
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the LocalSnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/hashicorp/go-multierror"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	settings_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/settings.mesh.gloo.solo.io/v1alpha2"
	settings_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/settings.mesh.gloo.solo.io/v1alpha2/sets"

	discovery_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/discovery.mesh.gloo.solo.io/v1alpha2"
	discovery_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/discovery.mesh.gloo.solo.io/v1alpha2/sets"

	networking_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1alpha2"
	networking_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1alpha2/sets"

	networking_enterprise_mesh_gloo_solo_io_v1alpha1 "github.com/solo-io/gloo-mesh/pkg/api/networking.enterprise.mesh.gloo.solo.io/v1alpha1"
	networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets "github.com/solo-io/gloo-mesh/pkg/api/networking.enterprise.mesh.gloo.solo.io/v1alpha1/sets"

	observability_enterprise_mesh_gloo_solo_io_v1alpha1 "github.com/solo-io/gloo-mesh/pkg/api/observability.enterprise.mesh.gloo.solo.io/v1alpha1"
	observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets "github.com/solo-io/gloo-mesh/pkg/api/observability.enterprise.mesh.gloo.solo.io/v1alpha1/sets"

	v1 "github.com/solo-io/external-apis/pkg/api/k8s/core/v1"
	v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/core/v1/sets"

	multicluster_solo_io_v1alpha1 "github.com/solo-io/skv2/pkg/api/multicluster.solo.io/v1alpha1"
	multicluster_solo_io_v1alpha1_sets "github.com/solo-io/skv2/pkg/api/multicluster.solo.io/v1alpha1/sets"
)

// the snapshot of input resources consumed by translation
type LocalSnapshot interface {

	// return the set of input Settings
	Settings() settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet

	// return the set of input TrafficTargets
	TrafficTargets() discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet
	// return the set of input Workloads
	Workloads() discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet
	// return the set of input Meshes
	Meshes() discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet

	// return the set of input TrafficPolicies
	TrafficPolicies() networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet
	// return the set of input AccessPolicies
	AccessPolicies() networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet
	// return the set of input VirtualMeshes
	VirtualMeshes() networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet
	// return the set of input FailoverServices
	FailoverServices() networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet

	// return the set of input WasmDeployments
	WasmDeployments() networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet

	// return the set of input AccessLogCollections
	AccessLogCollections() observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogCollectionSet

	// return the set of input Secrets
	Secrets() v1_sets.SecretSet

	// return the set of input KubernetesClusters
	KubernetesClusters() multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet
	// update the status of all input objects which support
	// the Status subresource (across multiple clusters)
	SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts LocalSyncStatusOptions) error
	// update the status of all input objects which support
	// the Status subresource (in the local cluster)
	SyncStatuses(ctx context.Context, c client.Client, opts LocalSyncStatusOptions) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

// options for syncing input object statuses
type LocalSyncStatusOptions struct {

	// sync status of Settings objects
	Settings bool

	// sync status of TrafficTarget objects
	TrafficTarget bool
	// sync status of Workload objects
	Workload bool
	// sync status of Mesh objects
	Mesh bool

	// sync status of TrafficPolicy objects
	TrafficPolicy bool
	// sync status of AccessPolicy objects
	AccessPolicy bool
	// sync status of VirtualMesh objects
	VirtualMesh bool
	// sync status of FailoverService objects
	FailoverService bool

	// sync status of WasmDeployment objects
	WasmDeployment bool

	// sync status of AccessLogCollection objects
	AccessLogCollection bool

	// sync status of Secret objects
	Secret bool

	// sync status of KubernetesCluster objects
	KubernetesCluster bool
}

type snapshotLocal struct {
	name string

	settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet

	trafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet
	workloads      discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet
	meshes         discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet

	trafficPolicies  networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet
	accessPolicies   networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet
	virtualMeshes    networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet
	failoverServices networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet

	wasmDeployments networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet

	accessLogCollections observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogCollectionSet

	secrets v1_sets.SecretSet

	kubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet
}

func NewLocalSnapshot(
	name string,

	settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet,

	trafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet,
	workloads discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet,
	meshes discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet,

	trafficPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet,
	accessPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet,
	virtualMeshes networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet,
	failoverServices networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet,

	wasmDeployments networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet,

	accessLogCollections observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogCollectionSet,

	secrets v1_sets.SecretSet,

	kubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet,

) LocalSnapshot {
	return &snapshotLocal{
		name: name,

		settings:             settings,
		trafficTargets:       trafficTargets,
		workloads:            workloads,
		meshes:               meshes,
		trafficPolicies:      trafficPolicies,
		accessPolicies:       accessPolicies,
		virtualMeshes:        virtualMeshes,
		failoverServices:     failoverServices,
		wasmDeployments:      wasmDeployments,
		accessLogCollections: accessLogCollections,
		secrets:              secrets,
		kubernetesClusters:   kubernetesClusters,
	}
}

func (s snapshotLocal) Settings() settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet {
	return s.settings
}

func (s snapshotLocal) TrafficTargets() discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet {
	return s.trafficTargets
}

func (s snapshotLocal) Workloads() discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet {
	return s.workloads
}

func (s snapshotLocal) Meshes() discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet {
	return s.meshes
}

func (s snapshotLocal) TrafficPolicies() networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet {
	return s.trafficPolicies
}

func (s snapshotLocal) AccessPolicies() networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet {
	return s.accessPolicies
}

func (s snapshotLocal) VirtualMeshes() networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet {
	return s.virtualMeshes
}

func (s snapshotLocal) FailoverServices() networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet {
	return s.failoverServices
}

func (s snapshotLocal) WasmDeployments() networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet {
	return s.wasmDeployments
}

func (s snapshotLocal) AccessLogCollections() observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogCollectionSet {
	return s.accessLogCollections
}

func (s snapshotLocal) Secrets() v1_sets.SecretSet {
	return s.secrets
}

func (s snapshotLocal) KubernetesClusters() multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet {
	return s.kubernetesClusters
}

func (s snapshotLocal) SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts LocalSyncStatusOptions) error {
	var errs error

	if opts.Settings {
		for _, obj := range s.Settings().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.TrafficTarget {
		for _, obj := range s.TrafficTargets().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Workload {
		for _, obj := range s.Workloads().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Mesh {
		for _, obj := range s.Meshes().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.TrafficPolicy {
		for _, obj := range s.TrafficPolicies().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.AccessPolicy {
		for _, obj := range s.AccessPolicies().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualMesh {
		for _, obj := range s.VirtualMeshes().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.FailoverService {
		for _, obj := range s.FailoverServices().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.WasmDeployment {
		for _, obj := range s.WasmDeployments().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.AccessLogCollection {
		for _, obj := range s.AccessLogCollections().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.KubernetesCluster {
		for _, obj := range s.KubernetesClusters().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	return errs
}

func (s snapshotLocal) SyncStatuses(ctx context.Context, c client.Client, opts LocalSyncStatusOptions) error {
	var errs error

	if opts.Settings {
		for _, obj := range s.Settings().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.TrafficTarget {
		for _, obj := range s.TrafficTargets().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Workload {
		for _, obj := range s.Workloads().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Mesh {
		for _, obj := range s.Meshes().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.TrafficPolicy {
		for _, obj := range s.TrafficPolicies().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.AccessPolicy {
		for _, obj := range s.AccessPolicies().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualMesh {
		for _, obj := range s.VirtualMeshes().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.FailoverService {
		for _, obj := range s.FailoverServices().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.WasmDeployment {
		for _, obj := range s.WasmDeployments().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.AccessLogCollection {
		for _, obj := range s.AccessLogCollections().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.KubernetesCluster {
		for _, obj := range s.KubernetesClusters().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	return errs
}

func (s snapshotLocal) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["settings"] = s.settings.List()
	snapshotMap["trafficTargets"] = s.trafficTargets.List()
	snapshotMap["workloads"] = s.workloads.List()
	snapshotMap["meshes"] = s.meshes.List()
	snapshotMap["trafficPolicies"] = s.trafficPolicies.List()
	snapshotMap["accessPolicies"] = s.accessPolicies.List()
	snapshotMap["virtualMeshes"] = s.virtualMeshes.List()
	snapshotMap["failoverServices"] = s.failoverServices.List()
	snapshotMap["wasmDeployments"] = s.wasmDeployments.List()
	snapshotMap["accessLogCollections"] = s.accessLogCollections.List()
	snapshotMap["secrets"] = s.secrets.List()
	snapshotMap["kubernetesClusters"] = s.kubernetesClusters.List()
	return json.Marshal(snapshotMap)
}

// builds the input snapshot from API Clients.
type LocalBuilder interface {
	BuildSnapshot(ctx context.Context, name string, opts LocalBuildOptions) (LocalSnapshot, error)
}

// Options for building a snapshot
type LocalBuildOptions struct {

	// List options for composing a snapshot from Settings
	Settings ResourceLocalBuildOptions

	// List options for composing a snapshot from TrafficTargets
	TrafficTargets ResourceLocalBuildOptions
	// List options for composing a snapshot from Workloads
	Workloads ResourceLocalBuildOptions
	// List options for composing a snapshot from Meshes
	Meshes ResourceLocalBuildOptions

	// List options for composing a snapshot from TrafficPolicies
	TrafficPolicies ResourceLocalBuildOptions
	// List options for composing a snapshot from AccessPolicies
	AccessPolicies ResourceLocalBuildOptions
	// List options for composing a snapshot from VirtualMeshes
	VirtualMeshes ResourceLocalBuildOptions
	// List options for composing a snapshot from FailoverServices
	FailoverServices ResourceLocalBuildOptions

	// List options for composing a snapshot from WasmDeployments
	WasmDeployments ResourceLocalBuildOptions

	// List options for composing a snapshot from AccessLogCollections
	AccessLogCollections ResourceLocalBuildOptions

	// List options for composing a snapshot from Secrets
	Secrets ResourceLocalBuildOptions

	// List options for composing a snapshot from KubernetesClusters
	KubernetesClusters ResourceLocalBuildOptions
}

// Options for reading resources of a given type
type ResourceLocalBuildOptions struct {

	// List options for composing a snapshot from a resource type
	ListOptions []client.ListOption

	// If provided, ensure the resource has been verified before adding it to snapshots
	Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources across multiple clusters
type multiClusterLocalBuilder struct {
	clusters multicluster.Interface
	client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterLocalBuilder(
	clusters multicluster.Interface,
	client multicluster.Client,
) LocalBuilder {
	return &multiClusterLocalBuilder{
		clusters: clusters,
		client:   client,
	}
}

func (b *multiClusterLocalBuilder) BuildSnapshot(ctx context.Context, name string, opts LocalBuildOptions) (LocalSnapshot, error) {

	settings := settings_mesh_gloo_solo_io_v1alpha2_sets.NewSettingsSet()

	trafficTargets := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficTargetSet()
	workloads := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewWorkloadSet()
	meshes := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewMeshSet()

	trafficPolicies := networking_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficPolicySet()
	accessPolicies := networking_mesh_gloo_solo_io_v1alpha2_sets.NewAccessPolicySet()
	virtualMeshes := networking_mesh_gloo_solo_io_v1alpha2_sets.NewVirtualMeshSet()
	failoverServices := networking_mesh_gloo_solo_io_v1alpha2_sets.NewFailoverServiceSet()

	wasmDeployments := networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewWasmDeploymentSet()

	accessLogCollections := observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewAccessLogCollectionSet()

	secrets := v1_sets.NewSecretSet()

	kubernetesClusters := multicluster_solo_io_v1alpha1_sets.NewKubernetesClusterSet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertSettingsFromCluster(ctx, cluster, settings, opts.Settings); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertTrafficTargetsFromCluster(ctx, cluster, trafficTargets, opts.TrafficTargets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertWorkloadsFromCluster(ctx, cluster, workloads, opts.Workloads); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertMeshesFromCluster(ctx, cluster, meshes, opts.Meshes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertTrafficPoliciesFromCluster(ctx, cluster, trafficPolicies, opts.TrafficPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertAccessPoliciesFromCluster(ctx, cluster, accessPolicies, opts.AccessPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertVirtualMeshesFromCluster(ctx, cluster, virtualMeshes, opts.VirtualMeshes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertFailoverServicesFromCluster(ctx, cluster, failoverServices, opts.FailoverServices); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertWasmDeploymentsFromCluster(ctx, cluster, wasmDeployments, opts.WasmDeployments); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertAccessLogCollectionsFromCluster(ctx, cluster, accessLogCollections, opts.AccessLogCollections); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertSecretsFromCluster(ctx, cluster, secrets, opts.Secrets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertKubernetesClustersFromCluster(ctx, cluster, kubernetesClusters, opts.KubernetesClusters); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewLocalSnapshot(
		name,

		settings,
		trafficTargets,
		workloads,
		meshes,
		trafficPolicies,
		accessPolicies,
		virtualMeshes,
		failoverServices,
		wasmDeployments,
		accessLogCollections,
		secrets,
		kubernetesClusters,
	)

	return outputSnap, errs
}

func (b *multiClusterLocalBuilder) insertSettingsFromCluster(ctx context.Context, cluster string, settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet, opts ResourceLocalBuildOptions) error {
	settingsClient, err := settings_mesh_gloo_solo_io_v1alpha2.NewMulticlusterSettingsClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "settings.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Settings",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	settingsList, err := settingsClient.ListSettings(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range settingsList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		settings.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertTrafficTargetsFromCluster(ctx context.Context, cluster string, trafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet, opts ResourceLocalBuildOptions) error {
	trafficTargetClient, err := discovery_mesh_gloo_solo_io_v1alpha2.NewMulticlusterTrafficTargetClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "TrafficTarget",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	trafficTargetList, err := trafficTargetClient.ListTrafficTarget(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range trafficTargetList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		trafficTargets.Insert(&item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertWorkloadsFromCluster(ctx context.Context, cluster string, workloads discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet, opts ResourceLocalBuildOptions) error {
	workloadClient, err := discovery_mesh_gloo_solo_io_v1alpha2.NewMulticlusterWorkloadClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Workload",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	workloadList, err := workloadClient.ListWorkload(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range workloadList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		workloads.Insert(&item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertMeshesFromCluster(ctx context.Context, cluster string, meshes discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet, opts ResourceLocalBuildOptions) error {
	meshClient, err := discovery_mesh_gloo_solo_io_v1alpha2.NewMulticlusterMeshClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Mesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	meshList, err := meshClient.ListMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range meshList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		meshes.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertTrafficPoliciesFromCluster(ctx context.Context, cluster string, trafficPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet, opts ResourceLocalBuildOptions) error {
	trafficPolicyClient, err := networking_mesh_gloo_solo_io_v1alpha2.NewMulticlusterTrafficPolicyClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "TrafficPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	trafficPolicyList, err := trafficPolicyClient.ListTrafficPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range trafficPolicyList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		trafficPolicies.Insert(&item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertAccessPoliciesFromCluster(ctx context.Context, cluster string, accessPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet, opts ResourceLocalBuildOptions) error {
	accessPolicyClient, err := networking_mesh_gloo_solo_io_v1alpha2.NewMulticlusterAccessPolicyClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "AccessPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	accessPolicyList, err := accessPolicyClient.ListAccessPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range accessPolicyList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		accessPolicies.Insert(&item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertVirtualMeshesFromCluster(ctx context.Context, cluster string, virtualMeshes networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet, opts ResourceLocalBuildOptions) error {
	virtualMeshClient, err := networking_mesh_gloo_solo_io_v1alpha2.NewMulticlusterVirtualMeshClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "VirtualMesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualMeshList, err := virtualMeshClient.ListVirtualMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualMeshList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		virtualMeshes.Insert(&item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertFailoverServicesFromCluster(ctx context.Context, cluster string, failoverServices networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet, opts ResourceLocalBuildOptions) error {
	failoverServiceClient, err := networking_mesh_gloo_solo_io_v1alpha2.NewMulticlusterFailoverServiceClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "FailoverService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	failoverServiceList, err := failoverServiceClient.ListFailoverService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range failoverServiceList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		failoverServices.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertWasmDeploymentsFromCluster(ctx context.Context, cluster string, wasmDeployments networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet, opts ResourceLocalBuildOptions) error {
	wasmDeploymentClient, err := networking_enterprise_mesh_gloo_solo_io_v1alpha1.NewMulticlusterWasmDeploymentClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1alpha1",
			Kind:    "WasmDeployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	wasmDeploymentList, err := wasmDeploymentClient.ListWasmDeployment(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range wasmDeploymentList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		wasmDeployments.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertAccessLogCollectionsFromCluster(ctx context.Context, cluster string, accessLogCollections observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogCollectionSet, opts ResourceLocalBuildOptions) error {
	accessLogCollectionClient, err := observability_enterprise_mesh_gloo_solo_io_v1alpha1.NewMulticlusterAccessLogCollectionClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "observability.enterprise.mesh.gloo.solo.io",
			Version: "v1alpha1",
			Kind:    "AccessLogCollection",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	accessLogCollectionList, err := accessLogCollectionClient.ListAccessLogCollection(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range accessLogCollectionList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		accessLogCollections.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertSecretsFromCluster(ctx context.Context, cluster string, secrets v1_sets.SecretSet, opts ResourceLocalBuildOptions) error {
	secretClient, err := v1.NewMulticlusterSecretClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Secret",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	secretList, err := secretClient.ListSecret(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range secretList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		secrets.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertKubernetesClustersFromCluster(ctx context.Context, cluster string, kubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet, opts ResourceLocalBuildOptions) error {
	kubernetesClusterClient, err := multicluster_solo_io_v1alpha1.NewMulticlusterKubernetesClusterClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "multicluster.solo.io",
			Version: "v1alpha1",
			Kind:    "KubernetesCluster",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	kubernetesClusterList, err := kubernetesClusterClient.ListKubernetesCluster(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range kubernetesClusterList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		kubernetesClusters.Insert(&item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterLocalBuilder struct {
	mgr         manager.Manager
	clusterName string
}

// Produces snapshots of resources read from the manager for the given cluster
func NewSingleClusterLocalBuilder(
	mgr manager.Manager,
) LocalBuilder {
	return NewSingleClusterLocalBuilderWithClusterName(mgr, "")
}

// Produces snapshots of resources read from the manager for the given cluster.
// Snapshot resources will be marked with the given ClusterName.
func NewSingleClusterLocalBuilderWithClusterName(
	mgr manager.Manager,
	clusterName string,
) LocalBuilder {
	return &singleClusterLocalBuilder{
		mgr:         mgr,
		clusterName: clusterName,
	}
}

func (b *singleClusterLocalBuilder) BuildSnapshot(ctx context.Context, name string, opts LocalBuildOptions) (LocalSnapshot, error) {

	settings := settings_mesh_gloo_solo_io_v1alpha2_sets.NewSettingsSet()

	trafficTargets := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficTargetSet()
	workloads := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewWorkloadSet()
	meshes := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewMeshSet()

	trafficPolicies := networking_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficPolicySet()
	accessPolicies := networking_mesh_gloo_solo_io_v1alpha2_sets.NewAccessPolicySet()
	virtualMeshes := networking_mesh_gloo_solo_io_v1alpha2_sets.NewVirtualMeshSet()
	failoverServices := networking_mesh_gloo_solo_io_v1alpha2_sets.NewFailoverServiceSet()

	wasmDeployments := networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewWasmDeploymentSet()

	accessLogCollections := observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewAccessLogCollectionSet()

	secrets := v1_sets.NewSecretSet()

	kubernetesClusters := multicluster_solo_io_v1alpha1_sets.NewKubernetesClusterSet()

	var errs error

	if err := b.insertSettings(ctx, settings, opts.Settings); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertTrafficTargets(ctx, trafficTargets, opts.TrafficTargets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertWorkloads(ctx, workloads, opts.Workloads); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertMeshes(ctx, meshes, opts.Meshes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertTrafficPolicies(ctx, trafficPolicies, opts.TrafficPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertAccessPolicies(ctx, accessPolicies, opts.AccessPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertVirtualMeshes(ctx, virtualMeshes, opts.VirtualMeshes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertFailoverServices(ctx, failoverServices, opts.FailoverServices); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertWasmDeployments(ctx, wasmDeployments, opts.WasmDeployments); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertAccessLogCollections(ctx, accessLogCollections, opts.AccessLogCollections); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertSecrets(ctx, secrets, opts.Secrets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertKubernetesClusters(ctx, kubernetesClusters, opts.KubernetesClusters); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewLocalSnapshot(
		name,

		settings,
		trafficTargets,
		workloads,
		meshes,
		trafficPolicies,
		accessPolicies,
		virtualMeshes,
		failoverServices,
		wasmDeployments,
		accessLogCollections,
		secrets,
		kubernetesClusters,
	)

	return outputSnap, errs
}

func (b *singleClusterLocalBuilder) insertSettings(ctx context.Context, settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "settings.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Settings",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	settingsList, err := settings_mesh_gloo_solo_io_v1alpha2.NewSettingsClient(b.mgr.GetClient()).ListSettings(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range settingsList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		settings.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertTrafficTargets(ctx context.Context, trafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "TrafficTarget",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	trafficTargetList, err := discovery_mesh_gloo_solo_io_v1alpha2.NewTrafficTargetClient(b.mgr.GetClient()).ListTrafficTarget(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range trafficTargetList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		trafficTargets.Insert(&item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertWorkloads(ctx context.Context, workloads discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Workload",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	workloadList, err := discovery_mesh_gloo_solo_io_v1alpha2.NewWorkloadClient(b.mgr.GetClient()).ListWorkload(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range workloadList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		workloads.Insert(&item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertMeshes(ctx context.Context, meshes discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Mesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	meshList, err := discovery_mesh_gloo_solo_io_v1alpha2.NewMeshClient(b.mgr.GetClient()).ListMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range meshList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		meshes.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertTrafficPolicies(ctx context.Context, trafficPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "TrafficPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	trafficPolicyList, err := networking_mesh_gloo_solo_io_v1alpha2.NewTrafficPolicyClient(b.mgr.GetClient()).ListTrafficPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range trafficPolicyList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		trafficPolicies.Insert(&item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertAccessPolicies(ctx context.Context, accessPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "AccessPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	accessPolicyList, err := networking_mesh_gloo_solo_io_v1alpha2.NewAccessPolicyClient(b.mgr.GetClient()).ListAccessPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range accessPolicyList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		accessPolicies.Insert(&item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertVirtualMeshes(ctx context.Context, virtualMeshes networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "VirtualMesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualMeshList, err := networking_mesh_gloo_solo_io_v1alpha2.NewVirtualMeshClient(b.mgr.GetClient()).ListVirtualMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualMeshList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		virtualMeshes.Insert(&item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertFailoverServices(ctx context.Context, failoverServices networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "FailoverService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	failoverServiceList, err := networking_mesh_gloo_solo_io_v1alpha2.NewFailoverServiceClient(b.mgr.GetClient()).ListFailoverService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range failoverServiceList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		failoverServices.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertWasmDeployments(ctx context.Context, wasmDeployments networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1alpha1",
			Kind:    "WasmDeployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	wasmDeploymentList, err := networking_enterprise_mesh_gloo_solo_io_v1alpha1.NewWasmDeploymentClient(b.mgr.GetClient()).ListWasmDeployment(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range wasmDeploymentList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		wasmDeployments.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertAccessLogCollections(ctx context.Context, accessLogCollections observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogCollectionSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "observability.enterprise.mesh.gloo.solo.io",
			Version: "v1alpha1",
			Kind:    "AccessLogCollection",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	accessLogCollectionList, err := observability_enterprise_mesh_gloo_solo_io_v1alpha1.NewAccessLogCollectionClient(b.mgr.GetClient()).ListAccessLogCollection(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range accessLogCollectionList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		accessLogCollections.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertSecrets(ctx context.Context, secrets v1_sets.SecretSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Secret",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	secretList, err := v1.NewSecretClient(b.mgr.GetClient()).ListSecret(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range secretList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		secrets.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertKubernetesClusters(ctx context.Context, kubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "multicluster.solo.io",
			Version: "v1alpha1",
			Kind:    "KubernetesCluster",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	kubernetesClusterList, err := multicluster_solo_io_v1alpha1.NewKubernetesClusterClient(b.mgr.GetClient()).ListKubernetesCluster(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range kubernetesClusterList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		kubernetesClusters.Insert(&item)
	}

	return nil
}

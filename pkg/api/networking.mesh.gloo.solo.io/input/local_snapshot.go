// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./local_snapshot.go -destination mocks/local_snapshot.go

// The Input LocalSnapshot contains the set of all:
// * WasmDeployments
// * RateLimiterServerConfigs
// * VirtualDestinations
// * VirtualGateways
// * VirtualHosts
// * RouteTables
// * ServiceDependencies
// * TrafficPolicies
// * AccessPolicies
// * VirtualMeshes
// * Settings
// * Destinations
// * Workloads
// * Meshes
// * AccessLogRecords
// * Secrets
// * KubernetesClusters
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the LocalSnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/skv2/pkg/resource"
	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/hashicorp/go-multierror"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	networking_enterprise_mesh_gloo_solo_io_v1beta1 "github.com/solo-io/gloo-mesh/pkg/api/networking.enterprise.mesh.gloo.solo.io/v1beta1"
	networking_enterprise_mesh_gloo_solo_io_v1beta1_types "github.com/solo-io/gloo-mesh/pkg/api/networking.enterprise.mesh.gloo.solo.io/v1beta1"
	networking_enterprise_mesh_gloo_solo_io_v1beta1_sets "github.com/solo-io/gloo-mesh/pkg/api/networking.enterprise.mesh.gloo.solo.io/v1beta1/sets"

	networking_mesh_gloo_solo_io_v1 "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1"
	networking_mesh_gloo_solo_io_v1_types "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1"
	networking_mesh_gloo_solo_io_v1_sets "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1/sets"

	settings_mesh_gloo_solo_io_v1 "github.com/solo-io/gloo-mesh/pkg/api/settings.mesh.gloo.solo.io/v1"
	settings_mesh_gloo_solo_io_v1_types "github.com/solo-io/gloo-mesh/pkg/api/settings.mesh.gloo.solo.io/v1"
	settings_mesh_gloo_solo_io_v1_sets "github.com/solo-io/gloo-mesh/pkg/api/settings.mesh.gloo.solo.io/v1/sets"

	discovery_mesh_gloo_solo_io_v1 "github.com/solo-io/gloo-mesh/pkg/api/discovery.mesh.gloo.solo.io/v1"
	discovery_mesh_gloo_solo_io_v1_types "github.com/solo-io/gloo-mesh/pkg/api/discovery.mesh.gloo.solo.io/v1"
	discovery_mesh_gloo_solo_io_v1_sets "github.com/solo-io/gloo-mesh/pkg/api/discovery.mesh.gloo.solo.io/v1/sets"

	observability_enterprise_mesh_gloo_solo_io_v1 "github.com/solo-io/gloo-mesh/pkg/api/observability.enterprise.mesh.gloo.solo.io/v1"
	observability_enterprise_mesh_gloo_solo_io_v1_types "github.com/solo-io/gloo-mesh/pkg/api/observability.enterprise.mesh.gloo.solo.io/v1"
	observability_enterprise_mesh_gloo_solo_io_v1_sets "github.com/solo-io/gloo-mesh/pkg/api/observability.enterprise.mesh.gloo.solo.io/v1/sets"

	v1 "github.com/solo-io/external-apis/pkg/api/k8s/core/v1"
	v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/core/v1/sets"
	v1_types "k8s.io/api/core/v1"

	multicluster_solo_io_v1alpha1 "github.com/solo-io/skv2/pkg/api/multicluster.solo.io/v1alpha1"
	multicluster_solo_io_v1alpha1_types "github.com/solo-io/skv2/pkg/api/multicluster.solo.io/v1alpha1"
	multicluster_solo_io_v1alpha1_sets "github.com/solo-io/skv2/pkg/api/multicluster.solo.io/v1alpha1/sets"
)

// SnapshotGVKs is a list of the GVKs included in this snapshot
var LocalSnapshotGVKs = []schema.GroupVersionKind{

	schema.GroupVersionKind{
		Group:   "networking.enterprise.mesh.gloo.solo.io",
		Version: "v1beta1",
		Kind:    "WasmDeployment",
	},
	schema.GroupVersionKind{
		Group:   "networking.enterprise.mesh.gloo.solo.io",
		Version: "v1beta1",
		Kind:    "RateLimiterServerConfig",
	},
	schema.GroupVersionKind{
		Group:   "networking.enterprise.mesh.gloo.solo.io",
		Version: "v1beta1",
		Kind:    "VirtualDestination",
	},
	schema.GroupVersionKind{
		Group:   "networking.enterprise.mesh.gloo.solo.io",
		Version: "v1beta1",
		Kind:    "VirtualGateway",
	},
	schema.GroupVersionKind{
		Group:   "networking.enterprise.mesh.gloo.solo.io",
		Version: "v1beta1",
		Kind:    "VirtualHost",
	},
	schema.GroupVersionKind{
		Group:   "networking.enterprise.mesh.gloo.solo.io",
		Version: "v1beta1",
		Kind:    "RouteTable",
	},
	schema.GroupVersionKind{
		Group:   "networking.enterprise.mesh.gloo.solo.io",
		Version: "v1beta1",
		Kind:    "ServiceDependency",
	},

	schema.GroupVersionKind{
		Group:   "networking.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "TrafficPolicy",
	},
	schema.GroupVersionKind{
		Group:   "networking.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "AccessPolicy",
	},
	schema.GroupVersionKind{
		Group:   "networking.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "VirtualMesh",
	},

	schema.GroupVersionKind{
		Group:   "settings.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "Settings",
	},

	schema.GroupVersionKind{
		Group:   "discovery.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "Destination",
	},
	schema.GroupVersionKind{
		Group:   "discovery.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "Workload",
	},
	schema.GroupVersionKind{
		Group:   "discovery.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "Mesh",
	},

	schema.GroupVersionKind{
		Group:   "observability.enterprise.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "AccessLogRecord",
	},

	schema.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "Secret",
	},

	schema.GroupVersionKind{
		Group:   "multicluster.solo.io",
		Version: "v1alpha1",
		Kind:    "KubernetesCluster",
	},
}

// the snapshot of input resources consumed by translation
type LocalSnapshot interface {

	// return the set of input WasmDeployments
	WasmDeployments() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.WasmDeploymentSet
	// return the set of input RateLimiterServerConfigs
	RateLimiterServerConfigs() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RateLimiterServerConfigSet
	// return the set of input VirtualDestinations
	VirtualDestinations() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualDestinationSet
	// return the set of input VirtualGateways
	VirtualGateways() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualGatewaySet
	// return the set of input VirtualHosts
	VirtualHosts() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualHostSet
	// return the set of input RouteTables
	RouteTables() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RouteTableSet
	// return the set of input ServiceDependencies
	ServiceDependencies() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.ServiceDependencySet

	// return the set of input TrafficPolicies
	TrafficPolicies() networking_mesh_gloo_solo_io_v1_sets.TrafficPolicySet
	// return the set of input AccessPolicies
	AccessPolicies() networking_mesh_gloo_solo_io_v1_sets.AccessPolicySet
	// return the set of input VirtualMeshes
	VirtualMeshes() networking_mesh_gloo_solo_io_v1_sets.VirtualMeshSet

	// return the set of input Settings
	Settings() settings_mesh_gloo_solo_io_v1_sets.SettingsSet

	// return the set of input Destinations
	Destinations() discovery_mesh_gloo_solo_io_v1_sets.DestinationSet
	// return the set of input Workloads
	Workloads() discovery_mesh_gloo_solo_io_v1_sets.WorkloadSet
	// return the set of input Meshes
	Meshes() discovery_mesh_gloo_solo_io_v1_sets.MeshSet

	// return the set of input AccessLogRecords
	AccessLogRecords() observability_enterprise_mesh_gloo_solo_io_v1_sets.AccessLogRecordSet

	// return the set of input Secrets
	Secrets() v1_sets.SecretSet

	// return the set of input KubernetesClusters
	KubernetesClusters() multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet
	// update the status of all input objects which support
	// the Status subresource (across multiple clusters)
	SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts LocalSyncStatusOptions) error
	// update the status of all input objects which support
	// the Status subresource (in the local cluster)
	SyncStatuses(ctx context.Context, c client.Client, opts LocalSyncStatusOptions) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)

	// Clone the snapshot
	Clone() LocalSnapshot
}

// options for syncing input object statuses
type LocalSyncStatusOptions struct {

	// sync status of WasmDeployment objects
	WasmDeployment bool
	// sync status of RateLimiterServerConfig objects
	RateLimiterServerConfig bool
	// sync status of VirtualDestination objects
	VirtualDestination bool
	// sync status of VirtualGateway objects
	VirtualGateway bool
	// sync status of VirtualHost objects
	VirtualHost bool
	// sync status of RouteTable objects
	RouteTable bool
	// sync status of ServiceDependency objects
	ServiceDependency bool

	// sync status of TrafficPolicy objects
	TrafficPolicy bool
	// sync status of AccessPolicy objects
	AccessPolicy bool
	// sync status of VirtualMesh objects
	VirtualMesh bool

	// sync status of Settings objects
	Settings bool

	// sync status of Destination objects
	Destination bool
	// sync status of Workload objects
	Workload bool
	// sync status of Mesh objects
	Mesh bool

	// sync status of AccessLogRecord objects
	AccessLogRecord bool

	// sync status of Secret objects
	Secret bool

	// sync status of KubernetesCluster objects
	KubernetesCluster bool
}

type snapshotLocal struct {
	name string

	wasmDeployments          networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.WasmDeploymentSet
	rateLimiterServerConfigs networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RateLimiterServerConfigSet
	virtualDestinations      networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualDestinationSet
	virtualGateways          networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualGatewaySet
	virtualHosts             networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualHostSet
	routeTables              networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RouteTableSet
	serviceDependencies      networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.ServiceDependencySet

	trafficPolicies networking_mesh_gloo_solo_io_v1_sets.TrafficPolicySet
	accessPolicies  networking_mesh_gloo_solo_io_v1_sets.AccessPolicySet
	virtualMeshes   networking_mesh_gloo_solo_io_v1_sets.VirtualMeshSet

	settings settings_mesh_gloo_solo_io_v1_sets.SettingsSet

	destinations discovery_mesh_gloo_solo_io_v1_sets.DestinationSet
	workloads    discovery_mesh_gloo_solo_io_v1_sets.WorkloadSet
	meshes       discovery_mesh_gloo_solo_io_v1_sets.MeshSet

	accessLogRecords observability_enterprise_mesh_gloo_solo_io_v1_sets.AccessLogRecordSet

	secrets v1_sets.SecretSet

	kubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet
}

func NewLocalSnapshot(
	name string,

	wasmDeployments networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.WasmDeploymentSet,
	rateLimiterServerConfigs networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RateLimiterServerConfigSet,
	virtualDestinations networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualDestinationSet,
	virtualGateways networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualGatewaySet,
	virtualHosts networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualHostSet,
	routeTables networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RouteTableSet,
	serviceDependencies networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.ServiceDependencySet,

	trafficPolicies networking_mesh_gloo_solo_io_v1_sets.TrafficPolicySet,
	accessPolicies networking_mesh_gloo_solo_io_v1_sets.AccessPolicySet,
	virtualMeshes networking_mesh_gloo_solo_io_v1_sets.VirtualMeshSet,

	settings settings_mesh_gloo_solo_io_v1_sets.SettingsSet,

	destinations discovery_mesh_gloo_solo_io_v1_sets.DestinationSet,
	workloads discovery_mesh_gloo_solo_io_v1_sets.WorkloadSet,
	meshes discovery_mesh_gloo_solo_io_v1_sets.MeshSet,

	accessLogRecords observability_enterprise_mesh_gloo_solo_io_v1_sets.AccessLogRecordSet,

	secrets v1_sets.SecretSet,

	kubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet,

) LocalSnapshot {
	return &snapshotLocal{
		name: name,

		wasmDeployments:          wasmDeployments,
		rateLimiterServerConfigs: rateLimiterServerConfigs,
		virtualDestinations:      virtualDestinations,
		virtualGateways:          virtualGateways,
		virtualHosts:             virtualHosts,
		routeTables:              routeTables,
		serviceDependencies:      serviceDependencies,
		trafficPolicies:          trafficPolicies,
		accessPolicies:           accessPolicies,
		virtualMeshes:            virtualMeshes,
		settings:                 settings,
		destinations:             destinations,
		workloads:                workloads,
		meshes:                   meshes,
		accessLogRecords:         accessLogRecords,
		secrets:                  secrets,
		kubernetesClusters:       kubernetesClusters,
	}
}

func NewLocalSnapshotFromGeneric(
	name string,
	genericSnapshot resource.ClusterSnapshot,
) LocalSnapshot {

	wasmDeploymentSet := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewWasmDeploymentSet()
	rateLimiterServerConfigSet := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewRateLimiterServerConfigSet()
	virtualDestinationSet := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualDestinationSet()
	virtualGatewaySet := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualGatewaySet()
	virtualHostSet := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualHostSet()
	routeTableSet := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewRouteTableSet()
	serviceDependencySet := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewServiceDependencySet()

	trafficPolicySet := networking_mesh_gloo_solo_io_v1_sets.NewTrafficPolicySet()
	accessPolicySet := networking_mesh_gloo_solo_io_v1_sets.NewAccessPolicySet()
	virtualMeshSet := networking_mesh_gloo_solo_io_v1_sets.NewVirtualMeshSet()

	settingsSet := settings_mesh_gloo_solo_io_v1_sets.NewSettingsSet()

	destinationSet := discovery_mesh_gloo_solo_io_v1_sets.NewDestinationSet()
	workloadSet := discovery_mesh_gloo_solo_io_v1_sets.NewWorkloadSet()
	meshSet := discovery_mesh_gloo_solo_io_v1_sets.NewMeshSet()

	accessLogRecordSet := observability_enterprise_mesh_gloo_solo_io_v1_sets.NewAccessLogRecordSet()

	secretSet := v1_sets.NewSecretSet()

	kubernetesClusterSet := multicluster_solo_io_v1alpha1_sets.NewKubernetesClusterSet()

	for _, snapshot := range genericSnapshot {

		wasmDeployments := snapshot[schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "WasmDeployment",
		}]

		for _, wasmDeployment := range wasmDeployments {
			wasmDeploymentSet.Insert(wasmDeployment.(*networking_enterprise_mesh_gloo_solo_io_v1beta1_types.WasmDeployment))
		}
		rateLimiterServerConfigs := snapshot[schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "RateLimiterServerConfig",
		}]

		for _, rateLimiterServerConfig := range rateLimiterServerConfigs {
			rateLimiterServerConfigSet.Insert(rateLimiterServerConfig.(*networking_enterprise_mesh_gloo_solo_io_v1beta1_types.RateLimiterServerConfig))
		}
		virtualDestinations := snapshot[schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "VirtualDestination",
		}]

		for _, virtualDestination := range virtualDestinations {
			virtualDestinationSet.Insert(virtualDestination.(*networking_enterprise_mesh_gloo_solo_io_v1beta1_types.VirtualDestination))
		}
		virtualGateways := snapshot[schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "VirtualGateway",
		}]

		for _, virtualGateway := range virtualGateways {
			virtualGatewaySet.Insert(virtualGateway.(*networking_enterprise_mesh_gloo_solo_io_v1beta1_types.VirtualGateway))
		}
		virtualHosts := snapshot[schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "VirtualHost",
		}]

		for _, virtualHost := range virtualHosts {
			virtualHostSet.Insert(virtualHost.(*networking_enterprise_mesh_gloo_solo_io_v1beta1_types.VirtualHost))
		}
		routeTables := snapshot[schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "RouteTable",
		}]

		for _, routeTable := range routeTables {
			routeTableSet.Insert(routeTable.(*networking_enterprise_mesh_gloo_solo_io_v1beta1_types.RouteTable))
		}
		serviceDependencies := snapshot[schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "ServiceDependency",
		}]

		for _, serviceDependency := range serviceDependencies {
			serviceDependencySet.Insert(serviceDependency.(*networking_enterprise_mesh_gloo_solo_io_v1beta1_types.ServiceDependency))
		}

		trafficPolicies := snapshot[schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "TrafficPolicy",
		}]

		for _, trafficPolicy := range trafficPolicies {
			trafficPolicySet.Insert(trafficPolicy.(*networking_mesh_gloo_solo_io_v1_types.TrafficPolicy))
		}
		accessPolicies := snapshot[schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "AccessPolicy",
		}]

		for _, accessPolicy := range accessPolicies {
			accessPolicySet.Insert(accessPolicy.(*networking_mesh_gloo_solo_io_v1_types.AccessPolicy))
		}
		virtualMeshes := snapshot[schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "VirtualMesh",
		}]

		for _, virtualMesh := range virtualMeshes {
			virtualMeshSet.Insert(virtualMesh.(*networking_mesh_gloo_solo_io_v1_types.VirtualMesh))
		}

		settings := snapshot[schema.GroupVersionKind{
			Group:   "settings.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Settings",
		}]

		for _, settings := range settings {
			settingsSet.Insert(settings.(*settings_mesh_gloo_solo_io_v1_types.Settings))
		}

		destinations := snapshot[schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Destination",
		}]

		for _, destination := range destinations {
			destinationSet.Insert(destination.(*discovery_mesh_gloo_solo_io_v1_types.Destination))
		}
		workloads := snapshot[schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Workload",
		}]

		for _, workload := range workloads {
			workloadSet.Insert(workload.(*discovery_mesh_gloo_solo_io_v1_types.Workload))
		}
		meshes := snapshot[schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Mesh",
		}]

		for _, mesh := range meshes {
			meshSet.Insert(mesh.(*discovery_mesh_gloo_solo_io_v1_types.Mesh))
		}

		accessLogRecords := snapshot[schema.GroupVersionKind{
			Group:   "observability.enterprise.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "AccessLogRecord",
		}]

		for _, accessLogRecord := range accessLogRecords {
			accessLogRecordSet.Insert(accessLogRecord.(*observability_enterprise_mesh_gloo_solo_io_v1_types.AccessLogRecord))
		}

		secrets := snapshot[schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Secret",
		}]

		for _, secret := range secrets {
			secretSet.Insert(secret.(*v1_types.Secret))
		}

		kubernetesClusters := snapshot[schema.GroupVersionKind{
			Group:   "multicluster.solo.io",
			Version: "v1alpha1",
			Kind:    "KubernetesCluster",
		}]

		for _, kubernetesCluster := range kubernetesClusters {
			kubernetesClusterSet.Insert(kubernetesCluster.(*multicluster_solo_io_v1alpha1_types.KubernetesCluster))
		}

	}
	return NewLocalSnapshot(
		name,
		wasmDeploymentSet,
		rateLimiterServerConfigSet,
		virtualDestinationSet,
		virtualGatewaySet,
		virtualHostSet,
		routeTableSet,
		serviceDependencySet,
		trafficPolicySet,
		accessPolicySet,
		virtualMeshSet,
		settingsSet,
		destinationSet,
		workloadSet,
		meshSet,
		accessLogRecordSet,
		secretSet,
		kubernetesClusterSet,
	)
}

func (s snapshotLocal) WasmDeployments() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.WasmDeploymentSet {
	return s.wasmDeployments
}

func (s snapshotLocal) RateLimiterServerConfigs() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RateLimiterServerConfigSet {
	return s.rateLimiterServerConfigs
}

func (s snapshotLocal) VirtualDestinations() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualDestinationSet {
	return s.virtualDestinations
}

func (s snapshotLocal) VirtualGateways() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualGatewaySet {
	return s.virtualGateways
}

func (s snapshotLocal) VirtualHosts() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualHostSet {
	return s.virtualHosts
}

func (s snapshotLocal) RouteTables() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RouteTableSet {
	return s.routeTables
}

func (s snapshotLocal) ServiceDependencies() networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.ServiceDependencySet {
	return s.serviceDependencies
}

func (s snapshotLocal) TrafficPolicies() networking_mesh_gloo_solo_io_v1_sets.TrafficPolicySet {
	return s.trafficPolicies
}

func (s snapshotLocal) AccessPolicies() networking_mesh_gloo_solo_io_v1_sets.AccessPolicySet {
	return s.accessPolicies
}

func (s snapshotLocal) VirtualMeshes() networking_mesh_gloo_solo_io_v1_sets.VirtualMeshSet {
	return s.virtualMeshes
}

func (s snapshotLocal) Settings() settings_mesh_gloo_solo_io_v1_sets.SettingsSet {
	return s.settings
}

func (s snapshotLocal) Destinations() discovery_mesh_gloo_solo_io_v1_sets.DestinationSet {
	return s.destinations
}

func (s snapshotLocal) Workloads() discovery_mesh_gloo_solo_io_v1_sets.WorkloadSet {
	return s.workloads
}

func (s snapshotLocal) Meshes() discovery_mesh_gloo_solo_io_v1_sets.MeshSet {
	return s.meshes
}

func (s snapshotLocal) AccessLogRecords() observability_enterprise_mesh_gloo_solo_io_v1_sets.AccessLogRecordSet {
	return s.accessLogRecords
}

func (s snapshotLocal) Secrets() v1_sets.SecretSet {
	return s.secrets
}

func (s snapshotLocal) KubernetesClusters() multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet {
	return s.kubernetesClusters
}

func (s snapshotLocal) SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts LocalSyncStatusOptions) error {
	var errs error

	if opts.WasmDeployment {
		for _, obj := range s.WasmDeployments().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.RateLimiterServerConfig {
		for _, obj := range s.RateLimiterServerConfigs().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualDestination {
		for _, obj := range s.VirtualDestinations().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualGateway {
		for _, obj := range s.VirtualGateways().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualHost {
		for _, obj := range s.VirtualHosts().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.RouteTable {
		for _, obj := range s.RouteTables().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.ServiceDependency {
		for _, obj := range s.ServiceDependencies().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.TrafficPolicy {
		for _, obj := range s.TrafficPolicies().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.AccessPolicy {
		for _, obj := range s.AccessPolicies().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualMesh {
		for _, obj := range s.VirtualMeshes().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.Settings {
		for _, obj := range s.Settings().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.Destination {
		for _, obj := range s.Destinations().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Workload {
		for _, obj := range s.Workloads().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Mesh {
		for _, obj := range s.Meshes().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.AccessLogRecord {
		for _, obj := range s.AccessLogRecords().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.KubernetesCluster {
		for _, obj := range s.KubernetesClusters().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	return errs
}

func (s snapshotLocal) SyncStatuses(ctx context.Context, c client.Client, opts LocalSyncStatusOptions) error {
	var errs error

	if opts.WasmDeployment {
		for _, obj := range s.WasmDeployments().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.RateLimiterServerConfig {
		for _, obj := range s.RateLimiterServerConfigs().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualDestination {
		for _, obj := range s.VirtualDestinations().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualGateway {
		for _, obj := range s.VirtualGateways().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualHost {
		for _, obj := range s.VirtualHosts().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.RouteTable {
		for _, obj := range s.RouteTables().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.ServiceDependency {
		for _, obj := range s.ServiceDependencies().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.TrafficPolicy {
		for _, obj := range s.TrafficPolicies().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.AccessPolicy {
		for _, obj := range s.AccessPolicies().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.VirtualMesh {
		for _, obj := range s.VirtualMeshes().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.Settings {
		for _, obj := range s.Settings().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.Destination {
		for _, obj := range s.Destinations().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Workload {
		for _, obj := range s.Workloads().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.Mesh {
		for _, obj := range s.Meshes().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.AccessLogRecord {
		for _, obj := range s.AccessLogRecords().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.KubernetesCluster {
		for _, obj := range s.KubernetesClusters().List() {
			if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	return errs
}

func (s snapshotLocal) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["wasmDeployments"] = s.wasmDeployments.List()
	snapshotMap["rateLimiterServerConfigs"] = s.rateLimiterServerConfigs.List()
	snapshotMap["virtualDestinations"] = s.virtualDestinations.List()
	snapshotMap["virtualGateways"] = s.virtualGateways.List()
	snapshotMap["virtualHosts"] = s.virtualHosts.List()
	snapshotMap["routeTables"] = s.routeTables.List()
	snapshotMap["serviceDependencies"] = s.serviceDependencies.List()
	snapshotMap["trafficPolicies"] = s.trafficPolicies.List()
	snapshotMap["accessPolicies"] = s.accessPolicies.List()
	snapshotMap["virtualMeshes"] = s.virtualMeshes.List()
	snapshotMap["settings"] = s.settings.List()
	snapshotMap["destinations"] = s.destinations.List()
	snapshotMap["workloads"] = s.workloads.List()
	snapshotMap["meshes"] = s.meshes.List()
	snapshotMap["accessLogRecords"] = s.accessLogRecords.List()
	snapshotMap["secrets"] = s.secrets.List()
	snapshotMap["kubernetesClusters"] = s.kubernetesClusters.List()
	return json.Marshal(snapshotMap)
}

func (s snapshotLocal) Clone() LocalSnapshot {
	return &snapshotLocal{
		name: s.name,

		wasmDeployments:          s.wasmDeployments.Clone(),
		rateLimiterServerConfigs: s.rateLimiterServerConfigs.Clone(),
		virtualDestinations:      s.virtualDestinations.Clone(),
		virtualGateways:          s.virtualGateways.Clone(),
		virtualHosts:             s.virtualHosts.Clone(),
		routeTables:              s.routeTables.Clone(),
		serviceDependencies:      s.serviceDependencies.Clone(),
		trafficPolicies:          s.trafficPolicies.Clone(),
		accessPolicies:           s.accessPolicies.Clone(),
		virtualMeshes:            s.virtualMeshes.Clone(),
		settings:                 s.settings.Clone(),
		destinations:             s.destinations.Clone(),
		workloads:                s.workloads.Clone(),
		meshes:                   s.meshes.Clone(),
		accessLogRecords:         s.accessLogRecords.Clone(),
		secrets:                  s.secrets.Clone(),
		kubernetesClusters:       s.kubernetesClusters.Clone(),
	}
}

// builds the input snapshot from API Clients.
type LocalBuilder interface {
	BuildSnapshot(ctx context.Context, name string, opts LocalBuildOptions) (LocalSnapshot, error)
}

// Options for building a snapshot
type LocalBuildOptions struct {

	// List options for composing a snapshot from WasmDeployments
	WasmDeployments ResourceLocalBuildOptions
	// List options for composing a snapshot from RateLimiterServerConfigs
	RateLimiterServerConfigs ResourceLocalBuildOptions
	// List options for composing a snapshot from VirtualDestinations
	VirtualDestinations ResourceLocalBuildOptions
	// List options for composing a snapshot from VirtualGateways
	VirtualGateways ResourceLocalBuildOptions
	// List options for composing a snapshot from VirtualHosts
	VirtualHosts ResourceLocalBuildOptions
	// List options for composing a snapshot from RouteTables
	RouteTables ResourceLocalBuildOptions
	// List options for composing a snapshot from ServiceDependencies
	ServiceDependencies ResourceLocalBuildOptions

	// List options for composing a snapshot from TrafficPolicies
	TrafficPolicies ResourceLocalBuildOptions
	// List options for composing a snapshot from AccessPolicies
	AccessPolicies ResourceLocalBuildOptions
	// List options for composing a snapshot from VirtualMeshes
	VirtualMeshes ResourceLocalBuildOptions

	// List options for composing a snapshot from Settings
	Settings ResourceLocalBuildOptions

	// List options for composing a snapshot from Destinations
	Destinations ResourceLocalBuildOptions
	// List options for composing a snapshot from Workloads
	Workloads ResourceLocalBuildOptions
	// List options for composing a snapshot from Meshes
	Meshes ResourceLocalBuildOptions

	// List options for composing a snapshot from AccessLogRecords
	AccessLogRecords ResourceLocalBuildOptions

	// List options for composing a snapshot from Secrets
	Secrets ResourceLocalBuildOptions

	// List options for composing a snapshot from KubernetesClusters
	KubernetesClusters ResourceLocalBuildOptions
}

// Options for reading resources of a given type
type ResourceLocalBuildOptions struct {

	// List options for composing a snapshot from a resource type
	ListOptions []client.ListOption

	// If provided, ensure the resource has been verified before adding it to snapshots
	Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources across multiple clusters
type multiClusterLocalBuilder struct {
	clusters multicluster.Interface
	client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterLocalBuilder(
	clusters multicluster.Interface,
	client multicluster.Client,
) LocalBuilder {
	return &multiClusterLocalBuilder{
		clusters: clusters,
		client:   client,
	}
}

func (b *multiClusterLocalBuilder) BuildSnapshot(ctx context.Context, name string, opts LocalBuildOptions) (LocalSnapshot, error) {

	wasmDeployments := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewWasmDeploymentSet()
	rateLimiterServerConfigs := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewRateLimiterServerConfigSet()
	virtualDestinations := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualDestinationSet()
	virtualGateways := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualGatewaySet()
	virtualHosts := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualHostSet()
	routeTables := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewRouteTableSet()
	serviceDependencies := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewServiceDependencySet()

	trafficPolicies := networking_mesh_gloo_solo_io_v1_sets.NewTrafficPolicySet()
	accessPolicies := networking_mesh_gloo_solo_io_v1_sets.NewAccessPolicySet()
	virtualMeshes := networking_mesh_gloo_solo_io_v1_sets.NewVirtualMeshSet()

	settings := settings_mesh_gloo_solo_io_v1_sets.NewSettingsSet()

	destinations := discovery_mesh_gloo_solo_io_v1_sets.NewDestinationSet()
	workloads := discovery_mesh_gloo_solo_io_v1_sets.NewWorkloadSet()
	meshes := discovery_mesh_gloo_solo_io_v1_sets.NewMeshSet()

	accessLogRecords := observability_enterprise_mesh_gloo_solo_io_v1_sets.NewAccessLogRecordSet()

	secrets := v1_sets.NewSecretSet()

	kubernetesClusters := multicluster_solo_io_v1alpha1_sets.NewKubernetesClusterSet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertWasmDeploymentsFromCluster(ctx, cluster, wasmDeployments, opts.WasmDeployments); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertRateLimiterServerConfigsFromCluster(ctx, cluster, rateLimiterServerConfigs, opts.RateLimiterServerConfigs); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertVirtualDestinationsFromCluster(ctx, cluster, virtualDestinations, opts.VirtualDestinations); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertVirtualGatewaysFromCluster(ctx, cluster, virtualGateways, opts.VirtualGateways); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertVirtualHostsFromCluster(ctx, cluster, virtualHosts, opts.VirtualHosts); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertRouteTablesFromCluster(ctx, cluster, routeTables, opts.RouteTables); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertServiceDependenciesFromCluster(ctx, cluster, serviceDependencies, opts.ServiceDependencies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertTrafficPoliciesFromCluster(ctx, cluster, trafficPolicies, opts.TrafficPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertAccessPoliciesFromCluster(ctx, cluster, accessPolicies, opts.AccessPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertVirtualMeshesFromCluster(ctx, cluster, virtualMeshes, opts.VirtualMeshes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertSettingsFromCluster(ctx, cluster, settings, opts.Settings); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDestinationsFromCluster(ctx, cluster, destinations, opts.Destinations); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertWorkloadsFromCluster(ctx, cluster, workloads, opts.Workloads); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertMeshesFromCluster(ctx, cluster, meshes, opts.Meshes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertAccessLogRecordsFromCluster(ctx, cluster, accessLogRecords, opts.AccessLogRecords); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertSecretsFromCluster(ctx, cluster, secrets, opts.Secrets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertKubernetesClustersFromCluster(ctx, cluster, kubernetesClusters, opts.KubernetesClusters); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewLocalSnapshot(
		name,

		wasmDeployments,
		rateLimiterServerConfigs,
		virtualDestinations,
		virtualGateways,
		virtualHosts,
		routeTables,
		serviceDependencies,
		trafficPolicies,
		accessPolicies,
		virtualMeshes,
		settings,
		destinations,
		workloads,
		meshes,
		accessLogRecords,
		secrets,
		kubernetesClusters,
	)

	return outputSnap, errs
}

func (b *multiClusterLocalBuilder) insertWasmDeploymentsFromCluster(ctx context.Context, cluster string, wasmDeployments networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.WasmDeploymentSet, opts ResourceLocalBuildOptions) error {
	wasmDeploymentClient, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewMulticlusterWasmDeploymentClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "WasmDeployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	wasmDeploymentList, err := wasmDeploymentClient.ListWasmDeployment(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range wasmDeploymentList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		wasmDeployments.Insert(item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertRateLimiterServerConfigsFromCluster(ctx context.Context, cluster string, rateLimiterServerConfigs networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RateLimiterServerConfigSet, opts ResourceLocalBuildOptions) error {
	rateLimiterServerConfigClient, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewMulticlusterRateLimiterServerConfigClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "RateLimiterServerConfig",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	rateLimiterServerConfigList, err := rateLimiterServerConfigClient.ListRateLimiterServerConfig(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range rateLimiterServerConfigList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		rateLimiterServerConfigs.Insert(item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertVirtualDestinationsFromCluster(ctx context.Context, cluster string, virtualDestinations networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualDestinationSet, opts ResourceLocalBuildOptions) error {
	virtualDestinationClient, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewMulticlusterVirtualDestinationClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "VirtualDestination",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualDestinationList, err := virtualDestinationClient.ListVirtualDestination(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualDestinationList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		virtualDestinations.Insert(item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertVirtualGatewaysFromCluster(ctx context.Context, cluster string, virtualGateways networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualGatewaySet, opts ResourceLocalBuildOptions) error {
	virtualGatewayClient, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewMulticlusterVirtualGatewayClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "VirtualGateway",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualGatewayList, err := virtualGatewayClient.ListVirtualGateway(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualGatewayList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		virtualGateways.Insert(item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertVirtualHostsFromCluster(ctx context.Context, cluster string, virtualHosts networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualHostSet, opts ResourceLocalBuildOptions) error {
	virtualHostClient, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewMulticlusterVirtualHostClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "VirtualHost",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualHostList, err := virtualHostClient.ListVirtualHost(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualHostList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		virtualHosts.Insert(item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertRouteTablesFromCluster(ctx context.Context, cluster string, routeTables networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RouteTableSet, opts ResourceLocalBuildOptions) error {
	routeTableClient, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewMulticlusterRouteTableClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "RouteTable",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	routeTableList, err := routeTableClient.ListRouteTable(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range routeTableList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		routeTables.Insert(item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertServiceDependenciesFromCluster(ctx context.Context, cluster string, serviceDependencies networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.ServiceDependencySet, opts ResourceLocalBuildOptions) error {
	serviceDependencyClient, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewMulticlusterServiceDependencyClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "ServiceDependency",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	serviceDependencyList, err := serviceDependencyClient.ListServiceDependency(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range serviceDependencyList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		serviceDependencies.Insert(item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertTrafficPoliciesFromCluster(ctx context.Context, cluster string, trafficPolicies networking_mesh_gloo_solo_io_v1_sets.TrafficPolicySet, opts ResourceLocalBuildOptions) error {
	trafficPolicyClient, err := networking_mesh_gloo_solo_io_v1.NewMulticlusterTrafficPolicyClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "TrafficPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	trafficPolicyList, err := trafficPolicyClient.ListTrafficPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range trafficPolicyList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		trafficPolicies.Insert(item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertAccessPoliciesFromCluster(ctx context.Context, cluster string, accessPolicies networking_mesh_gloo_solo_io_v1_sets.AccessPolicySet, opts ResourceLocalBuildOptions) error {
	accessPolicyClient, err := networking_mesh_gloo_solo_io_v1.NewMulticlusterAccessPolicyClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "AccessPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	accessPolicyList, err := accessPolicyClient.ListAccessPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range accessPolicyList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		accessPolicies.Insert(item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertVirtualMeshesFromCluster(ctx context.Context, cluster string, virtualMeshes networking_mesh_gloo_solo_io_v1_sets.VirtualMeshSet, opts ResourceLocalBuildOptions) error {
	virtualMeshClient, err := networking_mesh_gloo_solo_io_v1.NewMulticlusterVirtualMeshClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "VirtualMesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualMeshList, err := virtualMeshClient.ListVirtualMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualMeshList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		virtualMeshes.Insert(item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertSettingsFromCluster(ctx context.Context, cluster string, settings settings_mesh_gloo_solo_io_v1_sets.SettingsSet, opts ResourceLocalBuildOptions) error {
	settingsClient, err := settings_mesh_gloo_solo_io_v1.NewMulticlusterSettingsClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "settings.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Settings",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	settingsList, err := settingsClient.ListSettings(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range settingsList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		settings.Insert(item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertDestinationsFromCluster(ctx context.Context, cluster string, destinations discovery_mesh_gloo_solo_io_v1_sets.DestinationSet, opts ResourceLocalBuildOptions) error {
	destinationClient, err := discovery_mesh_gloo_solo_io_v1.NewMulticlusterDestinationClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Destination",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	destinationList, err := destinationClient.ListDestination(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range destinationList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		destinations.Insert(item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertWorkloadsFromCluster(ctx context.Context, cluster string, workloads discovery_mesh_gloo_solo_io_v1_sets.WorkloadSet, opts ResourceLocalBuildOptions) error {
	workloadClient, err := discovery_mesh_gloo_solo_io_v1.NewMulticlusterWorkloadClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Workload",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	workloadList, err := workloadClient.ListWorkload(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range workloadList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		workloads.Insert(item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertMeshesFromCluster(ctx context.Context, cluster string, meshes discovery_mesh_gloo_solo_io_v1_sets.MeshSet, opts ResourceLocalBuildOptions) error {
	meshClient, err := discovery_mesh_gloo_solo_io_v1.NewMulticlusterMeshClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Mesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	meshList, err := meshClient.ListMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range meshList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		meshes.Insert(item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertAccessLogRecordsFromCluster(ctx context.Context, cluster string, accessLogRecords observability_enterprise_mesh_gloo_solo_io_v1_sets.AccessLogRecordSet, opts ResourceLocalBuildOptions) error {
	accessLogRecordClient, err := observability_enterprise_mesh_gloo_solo_io_v1.NewMulticlusterAccessLogRecordClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "observability.enterprise.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "AccessLogRecord",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	accessLogRecordList, err := accessLogRecordClient.ListAccessLogRecord(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range accessLogRecordList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		accessLogRecords.Insert(item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertSecretsFromCluster(ctx context.Context, cluster string, secrets v1_sets.SecretSet, opts ResourceLocalBuildOptions) error {
	secretClient, err := v1.NewMulticlusterSecretClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Secret",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	secretList, err := secretClient.ListSecret(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range secretList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		secrets.Insert(item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertKubernetesClustersFromCluster(ctx context.Context, cluster string, kubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet, opts ResourceLocalBuildOptions) error {
	kubernetesClusterClient, err := multicluster_solo_io_v1alpha1.NewMulticlusterKubernetesClusterClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "multicluster.solo.io",
			Version: "v1alpha1",
			Kind:    "KubernetesCluster",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	kubernetesClusterList, err := kubernetesClusterClient.ListKubernetesCluster(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range kubernetesClusterList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		kubernetesClusters.Insert(item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterLocalBuilder struct {
	mgr         manager.Manager
	clusterName string
}

// Produces snapshots of resources read from the manager for the given cluster
func NewSingleClusterLocalBuilder(
	mgr manager.Manager,
) LocalBuilder {
	return NewSingleClusterLocalBuilderWithClusterName(mgr, "")
}

// Produces snapshots of resources read from the manager for the given cluster.
// Snapshot resources will be marked with the given ClusterName.
func NewSingleClusterLocalBuilderWithClusterName(
	mgr manager.Manager,
	clusterName string,
) LocalBuilder {
	return &singleClusterLocalBuilder{
		mgr:         mgr,
		clusterName: clusterName,
	}
}

func (b *singleClusterLocalBuilder) BuildSnapshot(ctx context.Context, name string, opts LocalBuildOptions) (LocalSnapshot, error) {

	wasmDeployments := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewWasmDeploymentSet()
	rateLimiterServerConfigs := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewRateLimiterServerConfigSet()
	virtualDestinations := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualDestinationSet()
	virtualGateways := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualGatewaySet()
	virtualHosts := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualHostSet()
	routeTables := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewRouteTableSet()
	serviceDependencies := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewServiceDependencySet()

	trafficPolicies := networking_mesh_gloo_solo_io_v1_sets.NewTrafficPolicySet()
	accessPolicies := networking_mesh_gloo_solo_io_v1_sets.NewAccessPolicySet()
	virtualMeshes := networking_mesh_gloo_solo_io_v1_sets.NewVirtualMeshSet()

	settings := settings_mesh_gloo_solo_io_v1_sets.NewSettingsSet()

	destinations := discovery_mesh_gloo_solo_io_v1_sets.NewDestinationSet()
	workloads := discovery_mesh_gloo_solo_io_v1_sets.NewWorkloadSet()
	meshes := discovery_mesh_gloo_solo_io_v1_sets.NewMeshSet()

	accessLogRecords := observability_enterprise_mesh_gloo_solo_io_v1_sets.NewAccessLogRecordSet()

	secrets := v1_sets.NewSecretSet()

	kubernetesClusters := multicluster_solo_io_v1alpha1_sets.NewKubernetesClusterSet()

	var errs error

	if err := b.insertWasmDeployments(ctx, wasmDeployments, opts.WasmDeployments); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertRateLimiterServerConfigs(ctx, rateLimiterServerConfigs, opts.RateLimiterServerConfigs); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertVirtualDestinations(ctx, virtualDestinations, opts.VirtualDestinations); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertVirtualGateways(ctx, virtualGateways, opts.VirtualGateways); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertVirtualHosts(ctx, virtualHosts, opts.VirtualHosts); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertRouteTables(ctx, routeTables, opts.RouteTables); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertServiceDependencies(ctx, serviceDependencies, opts.ServiceDependencies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertTrafficPolicies(ctx, trafficPolicies, opts.TrafficPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertAccessPolicies(ctx, accessPolicies, opts.AccessPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertVirtualMeshes(ctx, virtualMeshes, opts.VirtualMeshes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertSettings(ctx, settings, opts.Settings); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertDestinations(ctx, destinations, opts.Destinations); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertWorkloads(ctx, workloads, opts.Workloads); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertMeshes(ctx, meshes, opts.Meshes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertAccessLogRecords(ctx, accessLogRecords, opts.AccessLogRecords); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertSecrets(ctx, secrets, opts.Secrets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertKubernetesClusters(ctx, kubernetesClusters, opts.KubernetesClusters); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewLocalSnapshot(
		name,

		wasmDeployments,
		rateLimiterServerConfigs,
		virtualDestinations,
		virtualGateways,
		virtualHosts,
		routeTables,
		serviceDependencies,
		trafficPolicies,
		accessPolicies,
		virtualMeshes,
		settings,
		destinations,
		workloads,
		meshes,
		accessLogRecords,
		secrets,
		kubernetesClusters,
	)

	return outputSnap, errs
}

func (b *singleClusterLocalBuilder) insertWasmDeployments(ctx context.Context, wasmDeployments networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.WasmDeploymentSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "WasmDeployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	wasmDeploymentList, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewWasmDeploymentClient(b.mgr.GetClient()).ListWasmDeployment(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range wasmDeploymentList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		wasmDeployments.Insert(item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertRateLimiterServerConfigs(ctx context.Context, rateLimiterServerConfigs networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RateLimiterServerConfigSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "RateLimiterServerConfig",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	rateLimiterServerConfigList, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewRateLimiterServerConfigClient(b.mgr.GetClient()).ListRateLimiterServerConfig(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range rateLimiterServerConfigList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		rateLimiterServerConfigs.Insert(item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertVirtualDestinations(ctx context.Context, virtualDestinations networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualDestinationSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "VirtualDestination",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualDestinationList, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewVirtualDestinationClient(b.mgr.GetClient()).ListVirtualDestination(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualDestinationList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		virtualDestinations.Insert(item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertVirtualGateways(ctx context.Context, virtualGateways networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualGatewaySet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "VirtualGateway",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualGatewayList, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewVirtualGatewayClient(b.mgr.GetClient()).ListVirtualGateway(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualGatewayList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		virtualGateways.Insert(item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertVirtualHosts(ctx context.Context, virtualHosts networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualHostSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "VirtualHost",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualHostList, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewVirtualHostClient(b.mgr.GetClient()).ListVirtualHost(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualHostList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		virtualHosts.Insert(item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertRouteTables(ctx context.Context, routeTables networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RouteTableSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "RouteTable",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	routeTableList, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewRouteTableClient(b.mgr.GetClient()).ListRouteTable(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range routeTableList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		routeTables.Insert(item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertServiceDependencies(ctx context.Context, serviceDependencies networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.ServiceDependencySet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "ServiceDependency",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	serviceDependencyList, err := networking_enterprise_mesh_gloo_solo_io_v1beta1.NewServiceDependencyClient(b.mgr.GetClient()).ListServiceDependency(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range serviceDependencyList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		serviceDependencies.Insert(item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertTrafficPolicies(ctx context.Context, trafficPolicies networking_mesh_gloo_solo_io_v1_sets.TrafficPolicySet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "TrafficPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	trafficPolicyList, err := networking_mesh_gloo_solo_io_v1.NewTrafficPolicyClient(b.mgr.GetClient()).ListTrafficPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range trafficPolicyList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		trafficPolicies.Insert(item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertAccessPolicies(ctx context.Context, accessPolicies networking_mesh_gloo_solo_io_v1_sets.AccessPolicySet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "AccessPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	accessPolicyList, err := networking_mesh_gloo_solo_io_v1.NewAccessPolicyClient(b.mgr.GetClient()).ListAccessPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range accessPolicyList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		accessPolicies.Insert(item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertVirtualMeshes(ctx context.Context, virtualMeshes networking_mesh_gloo_solo_io_v1_sets.VirtualMeshSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "VirtualMesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualMeshList, err := networking_mesh_gloo_solo_io_v1.NewVirtualMeshClient(b.mgr.GetClient()).ListVirtualMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualMeshList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		virtualMeshes.Insert(item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertSettings(ctx context.Context, settings settings_mesh_gloo_solo_io_v1_sets.SettingsSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "settings.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Settings",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	settingsList, err := settings_mesh_gloo_solo_io_v1.NewSettingsClient(b.mgr.GetClient()).ListSettings(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range settingsList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		settings.Insert(item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertDestinations(ctx context.Context, destinations discovery_mesh_gloo_solo_io_v1_sets.DestinationSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Destination",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	destinationList, err := discovery_mesh_gloo_solo_io_v1.NewDestinationClient(b.mgr.GetClient()).ListDestination(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range destinationList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		destinations.Insert(item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertWorkloads(ctx context.Context, workloads discovery_mesh_gloo_solo_io_v1_sets.WorkloadSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Workload",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	workloadList, err := discovery_mesh_gloo_solo_io_v1.NewWorkloadClient(b.mgr.GetClient()).ListWorkload(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range workloadList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		workloads.Insert(item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertMeshes(ctx context.Context, meshes discovery_mesh_gloo_solo_io_v1_sets.MeshSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "Mesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	meshList, err := discovery_mesh_gloo_solo_io_v1.NewMeshClient(b.mgr.GetClient()).ListMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range meshList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		meshes.Insert(item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertAccessLogRecords(ctx context.Context, accessLogRecords observability_enterprise_mesh_gloo_solo_io_v1_sets.AccessLogRecordSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "observability.enterprise.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "AccessLogRecord",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	accessLogRecordList, err := observability_enterprise_mesh_gloo_solo_io_v1.NewAccessLogRecordClient(b.mgr.GetClient()).ListAccessLogRecord(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range accessLogRecordList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		accessLogRecords.Insert(item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertSecrets(ctx context.Context, secrets v1_sets.SecretSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Secret",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	secretList, err := v1.NewSecretClient(b.mgr.GetClient()).ListSecret(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range secretList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		secrets.Insert(item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertKubernetesClusters(ctx context.Context, kubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "multicluster.solo.io",
			Version: "v1alpha1",
			Kind:    "KubernetesCluster",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	kubernetesClusterList, err := multicluster_solo_io_v1alpha1.NewKubernetesClusterClient(b.mgr.GetClient()).ListKubernetesCluster(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range kubernetesClusterList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		kubernetesClusters.Insert(item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type inMemoryLocalBuilder struct {
	getSnapshot func() (resource.ClusterSnapshot, error)
}

// Produces snapshots of resources read from the manager for the given cluster
func NewInMemoryLocalBuilder(
	getSnapshot func() (resource.ClusterSnapshot, error),
) LocalBuilder {
	return &inMemoryLocalBuilder{
		getSnapshot: getSnapshot,
	}
}

func (i *inMemoryLocalBuilder) BuildSnapshot(ctx context.Context, name string, opts LocalBuildOptions) (LocalSnapshot, error) {
	genericSnap, err := i.getSnapshot()
	if err != nil {
		return nil, err
	}

	wasmDeployments := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewWasmDeploymentSet()
	rateLimiterServerConfigs := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewRateLimiterServerConfigSet()
	virtualDestinations := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualDestinationSet()
	virtualGateways := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualGatewaySet()
	virtualHosts := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewVirtualHostSet()
	routeTables := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewRouteTableSet()
	serviceDependencies := networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewServiceDependencySet()

	trafficPolicies := networking_mesh_gloo_solo_io_v1_sets.NewTrafficPolicySet()
	accessPolicies := networking_mesh_gloo_solo_io_v1_sets.NewAccessPolicySet()
	virtualMeshes := networking_mesh_gloo_solo_io_v1_sets.NewVirtualMeshSet()

	settings := settings_mesh_gloo_solo_io_v1_sets.NewSettingsSet()

	destinations := discovery_mesh_gloo_solo_io_v1_sets.NewDestinationSet()
	workloads := discovery_mesh_gloo_solo_io_v1_sets.NewWorkloadSet()
	meshes := discovery_mesh_gloo_solo_io_v1_sets.NewMeshSet()

	accessLogRecords := observability_enterprise_mesh_gloo_solo_io_v1_sets.NewAccessLogRecordSet()

	secrets := v1_sets.NewSecretSet()

	kubernetesClusters := multicluster_solo_io_v1alpha1_sets.NewKubernetesClusterSet()

	genericSnap.ForEachObject(func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject) {
		switch obj := obj.(type) {
		// insert WasmDeployments
		case *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.WasmDeployment:
			i.insertWasmDeployment(ctx, obj, wasmDeployments, opts)
		// insert RateLimiterServerConfigs
		case *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.RateLimiterServerConfig:
			i.insertRateLimiterServerConfig(ctx, obj, rateLimiterServerConfigs, opts)
		// insert VirtualDestinations
		case *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.VirtualDestination:
			i.insertVirtualDestination(ctx, obj, virtualDestinations, opts)
		// insert VirtualGateways
		case *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.VirtualGateway:
			i.insertVirtualGateway(ctx, obj, virtualGateways, opts)
		// insert VirtualHosts
		case *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.VirtualHost:
			i.insertVirtualHost(ctx, obj, virtualHosts, opts)
		// insert RouteTables
		case *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.RouteTable:
			i.insertRouteTable(ctx, obj, routeTables, opts)
		// insert ServiceDependencies
		case *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.ServiceDependency:
			i.insertServiceDependency(ctx, obj, serviceDependencies, opts)
		// insert TrafficPolicies
		case *networking_mesh_gloo_solo_io_v1_types.TrafficPolicy:
			i.insertTrafficPolicy(ctx, obj, trafficPolicies, opts)
		// insert AccessPolicies
		case *networking_mesh_gloo_solo_io_v1_types.AccessPolicy:
			i.insertAccessPolicy(ctx, obj, accessPolicies, opts)
		// insert VirtualMeshes
		case *networking_mesh_gloo_solo_io_v1_types.VirtualMesh:
			i.insertVirtualMesh(ctx, obj, virtualMeshes, opts)
		// insert Settings
		case *settings_mesh_gloo_solo_io_v1_types.Settings:
			i.insertSettings(ctx, obj, settings, opts)
		// insert Destinations
		case *discovery_mesh_gloo_solo_io_v1_types.Destination:
			i.insertDestination(ctx, obj, destinations, opts)
		// insert Workloads
		case *discovery_mesh_gloo_solo_io_v1_types.Workload:
			i.insertWorkload(ctx, obj, workloads, opts)
		// insert Meshes
		case *discovery_mesh_gloo_solo_io_v1_types.Mesh:
			i.insertMesh(ctx, obj, meshes, opts)
		// insert AccessLogRecords
		case *observability_enterprise_mesh_gloo_solo_io_v1_types.AccessLogRecord:
			i.insertAccessLogRecord(ctx, obj, accessLogRecords, opts)
		// insert Secrets
		case *v1_types.Secret:
			i.insertSecret(ctx, obj, secrets, opts)
		// insert KubernetesClusters
		case *multicluster_solo_io_v1alpha1_types.KubernetesCluster:
			i.insertKubernetesCluster(ctx, obj, kubernetesClusters, opts)
		}
	})

	return NewLocalSnapshot(
		name,

		wasmDeployments,
		rateLimiterServerConfigs,
		virtualDestinations,
		virtualGateways,
		virtualHosts,
		routeTables,
		serviceDependencies,
		trafficPolicies,
		accessPolicies,
		virtualMeshes,
		settings,
		destinations,
		workloads,
		meshes,
		accessLogRecords,
		secrets,
		kubernetesClusters,
	), nil
}

func (i *inMemoryLocalBuilder) insertWasmDeployment(
	ctx context.Context,
	wasmDeployment *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.WasmDeployment,
	wasmDeploymentSet networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.WasmDeploymentSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.WasmDeployments.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = wasmDeployment.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(wasmDeployment.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		wasmDeploymentSet.Insert(wasmDeployment)
	}
}
func (i *inMemoryLocalBuilder) insertRateLimiterServerConfig(
	ctx context.Context,
	rateLimiterServerConfig *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.RateLimiterServerConfig,
	rateLimiterServerConfigSet networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RateLimiterServerConfigSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.RateLimiterServerConfigs.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = rateLimiterServerConfig.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(rateLimiterServerConfig.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		rateLimiterServerConfigSet.Insert(rateLimiterServerConfig)
	}
}
func (i *inMemoryLocalBuilder) insertVirtualDestination(
	ctx context.Context,
	virtualDestination *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.VirtualDestination,
	virtualDestinationSet networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualDestinationSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.VirtualDestinations.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = virtualDestination.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(virtualDestination.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		virtualDestinationSet.Insert(virtualDestination)
	}
}
func (i *inMemoryLocalBuilder) insertVirtualGateway(
	ctx context.Context,
	virtualGateway *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.VirtualGateway,
	virtualGatewaySet networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualGatewaySet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.VirtualGateways.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = virtualGateway.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(virtualGateway.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		virtualGatewaySet.Insert(virtualGateway)
	}
}
func (i *inMemoryLocalBuilder) insertVirtualHost(
	ctx context.Context,
	virtualHost *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.VirtualHost,
	virtualHostSet networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.VirtualHostSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.VirtualHosts.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = virtualHost.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(virtualHost.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		virtualHostSet.Insert(virtualHost)
	}
}
func (i *inMemoryLocalBuilder) insertRouteTable(
	ctx context.Context,
	routeTable *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.RouteTable,
	routeTableSet networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.RouteTableSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.RouteTables.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = routeTable.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(routeTable.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		routeTableSet.Insert(routeTable)
	}
}
func (i *inMemoryLocalBuilder) insertServiceDependency(
	ctx context.Context,
	serviceDependency *networking_enterprise_mesh_gloo_solo_io_v1beta1_types.ServiceDependency,
	serviceDependencySet networking_enterprise_mesh_gloo_solo_io_v1beta1_sets.ServiceDependencySet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.ServiceDependencies.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = serviceDependency.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(serviceDependency.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		serviceDependencySet.Insert(serviceDependency)
	}
}

func (i *inMemoryLocalBuilder) insertTrafficPolicy(
	ctx context.Context,
	trafficPolicy *networking_mesh_gloo_solo_io_v1_types.TrafficPolicy,
	trafficPolicySet networking_mesh_gloo_solo_io_v1_sets.TrafficPolicySet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.TrafficPolicies.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = trafficPolicy.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(trafficPolicy.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		trafficPolicySet.Insert(trafficPolicy)
	}
}
func (i *inMemoryLocalBuilder) insertAccessPolicy(
	ctx context.Context,
	accessPolicy *networking_mesh_gloo_solo_io_v1_types.AccessPolicy,
	accessPolicySet networking_mesh_gloo_solo_io_v1_sets.AccessPolicySet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.AccessPolicies.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = accessPolicy.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(accessPolicy.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		accessPolicySet.Insert(accessPolicy)
	}
}
func (i *inMemoryLocalBuilder) insertVirtualMesh(
	ctx context.Context,
	virtualMesh *networking_mesh_gloo_solo_io_v1_types.VirtualMesh,
	virtualMeshSet networking_mesh_gloo_solo_io_v1_sets.VirtualMeshSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.VirtualMeshes.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = virtualMesh.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(virtualMesh.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		virtualMeshSet.Insert(virtualMesh)
	}
}

func (i *inMemoryLocalBuilder) insertSettings(
	ctx context.Context,
	settings *settings_mesh_gloo_solo_io_v1_types.Settings,
	settingsSet settings_mesh_gloo_solo_io_v1_sets.SettingsSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.Settings.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = settings.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(settings.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		settingsSet.Insert(settings)
	}
}

func (i *inMemoryLocalBuilder) insertDestination(
	ctx context.Context,
	destination *discovery_mesh_gloo_solo_io_v1_types.Destination,
	destinationSet discovery_mesh_gloo_solo_io_v1_sets.DestinationSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.Destinations.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = destination.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(destination.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		destinationSet.Insert(destination)
	}
}
func (i *inMemoryLocalBuilder) insertWorkload(
	ctx context.Context,
	workload *discovery_mesh_gloo_solo_io_v1_types.Workload,
	workloadSet discovery_mesh_gloo_solo_io_v1_sets.WorkloadSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.Workloads.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = workload.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(workload.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		workloadSet.Insert(workload)
	}
}
func (i *inMemoryLocalBuilder) insertMesh(
	ctx context.Context,
	mesh *discovery_mesh_gloo_solo_io_v1_types.Mesh,
	meshSet discovery_mesh_gloo_solo_io_v1_sets.MeshSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.Meshes.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = mesh.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(mesh.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		meshSet.Insert(mesh)
	}
}

func (i *inMemoryLocalBuilder) insertAccessLogRecord(
	ctx context.Context,
	accessLogRecord *observability_enterprise_mesh_gloo_solo_io_v1_types.AccessLogRecord,
	accessLogRecordSet observability_enterprise_mesh_gloo_solo_io_v1_sets.AccessLogRecordSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.AccessLogRecords.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = accessLogRecord.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(accessLogRecord.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		accessLogRecordSet.Insert(accessLogRecord)
	}
}

func (i *inMemoryLocalBuilder) insertSecret(
	ctx context.Context,
	secret *v1_types.Secret,
	secretSet v1_sets.SecretSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.Secrets.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = secret.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(secret.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		secretSet.Insert(secret)
	}
}

func (i *inMemoryLocalBuilder) insertKubernetesCluster(
	ctx context.Context,
	kubernetesCluster *multicluster_solo_io_v1alpha1_types.KubernetesCluster,
	kubernetesClusterSet multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet,
	buildOpts LocalBuildOptions,
) {

	opts := buildOpts.KubernetesClusters.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = kubernetesCluster.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(kubernetesCluster.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		kubernetesClusterSet.Insert(kubernetesCluster)
	}
}
